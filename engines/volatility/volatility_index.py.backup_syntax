"""
Volatility Index (VIX-style) - Market Fear and Uncertainty Measurement
Measures implied volatility and market stress levels for risk assessment.
Used for portfolio hedging, timing entries/exits, and market sentiment analysis.
"""

from typing import List, Dict, Any, Optional
import numpy as np
import pandas as pd
from dataclasses import dataclass
from datetime import datetime
from ..indicator_base import BaseIndicator, IndicatorResult, IndicatorSignal, SignalType, IndicatorType, MarketData, TimeFrame

# Platform3 Winston-style Logging Integration
import sys
import os

# Platform3 Error Handling Integration
from shared.error_handling.platform3_error_system import ServiceError, EventEmitter, CircuitBreaker, ErrorSeverity, ErrorCategory
from shared.error_handling.base_service import BaseService

sys.path.append(os.path.join(os.path.dirname(__file__), '../../shared'))
from logging.platform3_logger import Platform3Logger, log_performance, LogMetadata


@dataclass
class VolatilityIndexConfig, BaseService:
    """Configuration for Volatility Index"""
    period: int = 20
    calculation_method: str = 'parkinson'  # 'parkinson', 'garman_klass', 'rogers_satchell', 'simple'
    annualization_factor: float = 252.0  # Trading days per year
    extreme_threshold: float = 25.0  # Extreme volatility level
    high_threshold: float = 20.0  # High volatility level
    low_threshold: float = 10.0  # Low volatility level


class VolatilityIndex(BaseIndicator):
    """
    Volatility Index Implementation
    
    Calculates market volatility using various methods:
    1. Parkinson - Uses high-low range for better accuracy
    2. Garman-Klass - Incorporates open, high, low, close
    3. Rogers-Satchell - Drift-independent estimator
    4. Simple - Standard deviation of returns
    
    Features:
    - Multiple volatility calculation methods
    - Volatility regime detection
    - Market stress level analysis
    - Risk assessment signals
    - Volatility clustering identification
    """
    
    def __init__(self, config: Optional[VolatilityIndexConfig] = None):
        super().__init__(
            name="Volatility Index",
            indicator_type=IndicatorType.VOLATILITY,
            timeframe=TimeFrame.H1,
            lookback_periods=25
        )
        self.config = config or VolatilityIndexConfig()
        self.volatility_values: List[float] = []
        self.returns: List[float] = []
        self.volatility_regime: List[str] = []
        
    def calculate(self, data: List[MarketData]) -> IndicatorResult:
        try:
        """Calculate Volatility Index values"""
        try:
            if len(data) < self.config.period + 5:
                return IndicatorResult(
                    timestamp=data[-1].timestamp if data else datetime.now(),
                    indicator_name=self.name,
                    indicator_type=self.indicator_type,
                    timeframe=self.timeframe,
                    value=0.0,
                    signal=None,
                    raw_data={'error': f"Insufficient data: need {self.config.period + 5}, got {len(data)}"}
                )
            
            # Calculate volatility using selected method
            if self.config.calculation_method == 'parkinson':
                volatility_values = self._calculate_parkinson_volatility(data)
            elif self.config.calculation_method == 'garman_klass':
                volatility_values = self._calculate_garman_klass_volatility(data)
            elif self.config.calculation_method == 'rogers_satchell':
                volatility_values = self._calculate_rogers_satchell_volatility(data)
            else:  # simple
                volatility_values = self._calculate_simple_volatility(data)
            
            # Annualize volatility (convert to percentage)
            annualized_volatility = [v * np.sqrt(self.config.annualization_factor) * 100 
                                   for v in volatility_values]
            
            # Identify volatility regimes
            regimes = self._identify_volatility_regimes(annualized_volatility)
            
            # Calculate volatility momentum and clustering
            momentum = self._calculate_volatility_momentum(annualized_volatility)
            clustering = self._detect_volatility_clustering(annualized_volatility)
            
            # Store values
            self.volatility_values = annualized_volatility
            self.volatility_regime = regimes
            
            # Generate signals
            signals = self._generate_signals(data, annualized_volatility, regimes)
            # Calculate statistics
            stats = self._calculate_statistics(annualized_volatility)
            
            # Create signal
            signal = self.generate_signal(
                IndicatorResult(
                    timestamp=data[-1].timestamp,
                    indicator_name=self.name,
                    indicator_type=self.indicator_type,
                    timeframe=self.timeframe,
                    value=annualized_volatility[-1] if annualized_volatility else 0.0
                ),
                []
            )
            
            return IndicatorResult(
                timestamp=data[-1].timestamp,
                indicator_name=self.name,
                indicator_type=self.indicator_type,
                timeframe=self.timeframe,
                value={
                    'volatility': annualized_volatility[-1] if annualized_volatility else 0.0,
                    'volatility_values': annualized_volatility,
                    'regimes': regimes,
                    'momentum': momentum,
                    'clustering': clustering,
                    'percentile_rank': self._calculate_percentile_ranks(annualized_volatility)
                },
                signal=signal,
                raw_data={
                    'method': self.config.calculation_method,
                    'current_volatility': annualized_volatility[-1] if annualized_volatility else 0,
                    'current_regime': regimes[-1] if regimes else 'unknown',
                    'volatility_momentum': momentum[-1] if momentum else 0,
                    'clustering_factor': clustering[-1] if clustering else 0,
                    'market_stress_level': self._assess_market_stress(annualized_volatility[-1] if annualized_volatility else 0),
                    **stats
                }
            )
            
        except Exception as e:
            return IndicatorResult(
                timestamp=data[-1].timestamp if data else datetime.now(),
                indicator_name=self.name,
                indicator_type=self.indicator_type,
                timeframe=self.timeframe,
                value=0.0,
                signal=None,
                raw_data={'error': f"Volatility Index calculation failed: {str(e)}"}
            )
    
    def _calculate_parkinson_volatility(self, data: List[MarketData]) -> List[float]:
        try:
        """Calculate Parkinson volatility estimator"""
        volatility_values = []
        
        for i in range(self.config.period - 1, len(data)):
            window_data = data[i - self.config.period + 1:i + 1]
            
            # Parkinson estimator: (1/4*ln(2)) * sum(ln(H/L)^2)
            hl_ratios = []
            for candle in window_data:
                if candle.low > 0:
                    hl_ratio = np.log(candle.high / candle.low)
                    hl_ratios.append(hl_ratio ** 2)
            
            if hl_ratios:
                parkinson_vol = np.sqrt((1 / (4 * np.log(2))) * np.mean(hl_ratios))
                volatility_values.append(parkinson_vol)
            else:
                volatility_values.append(0.0)
        
        return volatility_values
    
    def _calculate_garman_klass_volatility(self, data: List[MarketData]) -> List[float]:
        try:
        """Calculate Garman-Klass volatility estimator"""
        volatility_values = []
        
        for i in range(self.config.period - 1, len(data)):
            window_data = data[i - self.config.period + 1:i + 1]
            
            gk_components = []
            for candle in window_data:
                if candle.low > 0 and candle.open > 0:
                    # GK = ln(H/C) * ln(H/O) + ln(L/C) * ln(L/O)
                    hl_component = np.log(candle.high / candle.close) * np.log(candle.high / candle.open)
                    ll_component = np.log(candle.low / candle.close) * np.log(candle.low / candle.open)
                    gk_components.append(hl_component + ll_component)
            
            if gk_components:
                gk_vol = np.sqrt(np.mean(gk_components))
                volatility_values.append(gk_vol)
            else:
                volatility_values.append(0.0)
        
        return volatility_values
    
    def _calculate_rogers_satchell_volatility(self, data: List[MarketData]) -> List[float]:
        try:
        """Calculate Rogers-Satchell volatility estimator"""
        volatility_values = []
        
        for i in range(self.config.period - 1, len(data)):
            window_data = data[i - self.config.period + 1:i + 1]
            
            rs_components = []
            for candle in window_data:
                if candle.low > 0 and candle.open > 0:
                    # RS = ln(H/C) * ln(H/O) + ln(L/C) * ln(L/O)
                    rs_value = (np.log(candle.high / candle.close) * np.log(candle.high / candle.open) +
                               np.log(candle.low / candle.close) * np.log(candle.low / candle.open))
                    rs_components.append(rs_value)
            
            if rs_components:
                rs_vol = np.sqrt(np.mean(rs_components))
                volatility_values.append(rs_vol)
            else:
                volatility_values.append(0.0)
        
        return volatility_values
    
    def _calculate_simple_volatility(self, data: List[MarketData]) -> List[float]:
        try:
        """Calculate simple volatility (standard deviation of returns)"""
        volatility_values = []
        
        # Calculate returns
        returns = []
        for i in range(1, len(data)):
            if data[i-1].close > 0:
                return_val = np.log(data[i].close / data[i-1].close)
                returns.append(return_val)
        
        # Calculate rolling volatility
        for i in range(self.config.period - 1, len(returns)):
            window_returns = returns[i - self.config.period + 1:i + 1]
            vol = np.std(window_returns)
            volatility_values.append(vol)
        
        return volatility_values
    
    def _identify_volatility_regimes(self, volatility_values: List[float]) -> List[str]:
        try:
        """Identify volatility regimes"""
        regimes = []
        
        for vol in volatility_values:
            if vol >= self.config.extreme_threshold:
                regimes.append('extreme')
            elif vol >= self.config.high_threshold:
                regimes.append('high')
            elif vol <= self.config.low_threshold:
                regimes.append('low')
            else:
                regimes.append('normal')
        
        return regimes
    
    def _calculate_volatility_momentum(self, volatility_values: List[float]) -> List[float]:
        try:
        """Calculate volatility momentum (rate of change in volatility)"""
        momentum = []
        
        for i in range(len(volatility_values)):
            if i >= 5:  # 5-period momentum
                current = volatility_values[i]
                previous = volatility_values[i-5]
                if previous > 0:
                    mom = (current - previous) / previous * 100
                    momentum.append(mom)
                else:
                    momentum.append(0.0)
            else:
                momentum.append(0.0)
        
        return momentum
    
    def _detect_volatility_clustering(self, volatility_values: List[float]) -> List[float]:
        try:
        """Detect volatility clustering using autocorrelation"""
        clustering = []
        
        for i in range(len(volatility_values)):
            if i >= 10:  # Need minimum data for clustering analysis
                recent_volatility = volatility_values[i-9:i+1]
                
                # Calculate autocorrelation at lag 1
                if len(recent_volatility) >= 2:
                    mean_vol = np.mean(recent_volatility)
                    numerator = sum((recent_volatility[j] - mean_vol) * (recent_volatility[j-1] - mean_vol) 
                                  for j in range(1, len(recent_volatility)))
                    denominator = sum((v - mean_vol) ** 2 for v in recent_volatility)
                    
                    if denominator > 0:
                        autocorr = numerator / denominator
                        clustering.append(autocorr)
                    else:
                        clustering.append(0.0)
                else:
                    clustering.append(0.0)
            else:
                clustering.append(0.0)
        
        return clustering
    
    def _calculate_percentile_ranks(self, volatility_values: List[float]) -> List[float]:
        try:
        """Calculate percentile ranks for volatility values"""
        percentiles = []
        
        for i in range(len(volatility_values)):
            if i >= self.config.period:
                window = volatility_values[i-self.config.period:i+1]
                current = volatility_values[i]
                rank = sum(1 for v in window if v <= current) / len(window) * 100
                percentiles.append(rank)
            else:
                percentiles.append(50.0)  # Default to median
        
        return percentiles
    
    def _assess_market_stress(self, current_volatility: float) -> str:
        try:
        """Assess current market stress level"""
        if current_volatility >= self.config.extreme_threshold:
            return 'extreme_stress'
        elif current_volatility >= self.config.high_threshold:
            return 'high_stress'
        elif current_volatility <= self.config.low_threshold:
            return 'low_stress'
        else:
            return 'normal_stress'
    
    def _calculate_statistics(self, volatility_values: List[float]) -> Dict[str, float]:
        try:
        """Calculate statistical measures for volatility"""
        if not volatility_values:
            return {}
        
        return {
            'avg_volatility': np.mean(volatility_values),
            'median_volatility': np.median(volatility_values),
            'volatility_std': np.std(volatility_values),
            'max_volatility': max(volatility_values),
            'min_volatility': min(volatility_values),
            'volatility_range': max(volatility_values) - min(volatility_values),
            'volatility_skewness': self._calculate_skewness(volatility_values),
            'volatility_kurtosis': self._calculate_kurtosis(volatility_values)
        }
    
    def _calculate_skewness(self, values: List[float]) -> float:
        try:
        """Calculate skewness of volatility distribution"""
        if len(values) < 3:
            return 0.0
        
        mean_val = np.mean(values)
        std_val = np.std(values)
        
        if std_val == 0:
            return 0.0
        skewness = np.mean([((v - mean_val) / std_val) ** 3 for v in values])
        return skewness
    
    def _calculate_kurtosis(self, values: List[float]) -> float:
        try:
        """Calculate kurtosis of volatility distribution"""
        if len(values) < 4:
            return 0.0
        
        mean_val = np.mean(values)
        std_val = np.std(values)
        
        if std_val == 0:
            return 0.0
        
        kurtosis = np.mean([((v - mean_val) / std_val) ** 4 for v in values]) - 3
        return kurtosis
    
    def generate_signal(self, current_result: IndicatorResult, 
        try:
                       historical_results: List[IndicatorResult]) -> Optional[IndicatorSignal]:
        """Generate trading signal based on volatility analysis"""
        if not current_result.value or not self.volatility_values:
            return IndicatorSignal(
                timestamp=current_result.timestamp,
                indicator_name=self.name,
                signal_type=SignalType.HOLD,
                strength=0.0,
                confidence=0.0,
                metadata={'error': 'insufficient_data'}
            )
        
        current_vol = self.volatility_values[-1]
        current_regime = self.volatility_regime[-1] if self.volatility_regime else 'unknown'
        # High volatility - caution signal
        if current_vol >= self.config.extreme_threshold:
            return IndicatorSignal(
                timestamp=current_result.timestamp,
                indicator_name=self.name,
                signal_type=SignalType.WARNING,
                strength=0.8,
                confidence=0.9,
                metadata={
                    'pattern': 'extreme_volatility',
                    'volatility': current_vol,
                    'regime': current_regime,
                    'recommendation': 'reduce_position_size'
                }
            )
        
        # Low volatility - opportunity signal
        elif current_vol <= self.config.low_threshold:
            return IndicatorSignal(
                timestamp=current_result.timestamp,
                indicator_name=self.name,
                signal_type=SignalType.BUY,
                strength=0.6,
                confidence=0.7,
                metadata={
                    'pattern': 'low_volatility_opportunity',
                    'volatility': current_vol,
                    'regime': current_regime,
                    'recommendation': 'consider_position_increase'
                }
            )
        
        # Normal volatility
        else:
            return IndicatorSignal(
                timestamp=current_result.timestamp,
                indicator_name=self.name,
                signal_type=SignalType.HOLD,
                strength=0.3,
                confidence=0.6,
                metadata={
                    'pattern': 'normal_volatility',
                    'volatility': current_vol,
                    'regime': current_regime
                }
            )

    def _generate_signals(self, data: List[MarketData], volatility_values: List[float], 
        try:
                         regimes: List[str]) -> List[IndicatorSignal]:
        """Generate multiple signals based on volatility analysis"""
        signals = []
        
        if not volatility_values:
            return signals
        
        current_vol = volatility_values[-1]
        current_regime = regimes[-1] if regimes else 'unknown'
        current_timestamp = data[-1].timestamp if data else datetime.now()
        
        # Volatility regime signals
        if current_regime == 'extreme':
            signals.append(IndicatorSignal(
                timestamp=current_timestamp,
                indicator_name=self.name,
                signal_type=SignalType.WARNING,
                strength=0.9,
                confidence=0.9,
                metadata={
                    'pattern': 'volatility_extreme_regime',
                    'volatility': current_vol,
                    'regime': current_regime
                }
            ))
        
        elif current_regime == 'low':
            signals.append(IndicatorSignal(
                timestamp=current_timestamp,
                indicator_name=self.name,
                signal_type=SignalType.BUY,
                strength=0.6,
                confidence=0.7,
                metadata={
                    'pattern': 'volatility_low_regime',
                    'volatility': current_vol,
                    'regime': current_regime
                }
            ))
        
        # Volatility breakout signals
        if len(volatility_values) >= 10:
            recent_avg = np.mean(volatility_values[-10:-1])
            if current_vol > recent_avg * 1.5:  # 50% increase
                signals.append(IndicatorSignal(
                    timestamp=current_timestamp,
                    indicator_name=self.name,
                    signal_type=SignalType.WARNING,
                    strength=0.7,
                    confidence=0.8,
                    metadata={
                        'pattern': 'volatility_breakout',
                        'current_vol': current_vol,
                        'recent_avg': recent_avg,
                        'increase_pct': (current_vol / recent_avg - 1) * 100
                    }
                ))
        
        return signals


    def handle_service_error(self, error: Exception, context: Dict[str, Any] = None) -> None:
        """Handle service errors with proper event emission and logging"""
        try:
            service_error = ServiceError(
                message=str(error),
                code=f"{self.__class__.__name__.upper()}_ERROR",
                metadata={
                    "file_path": "engines/volatility/volatility_index.py",
                    "context": context or {},
                    "timestamp": pd.Timestamp.now().isoformat(),
                    "service_name": self.__class__.__name__
                }
            )
            
            # Emit error event for monitoring
            self.emit('error', service_error)
            
            # Log error with correlation context
            if hasattr(self, 'logger'):
                self.logger.error(
                    f"Service error in {self.__class__.__name__}: {str(error)}",
                    extra={
                        "error_code": service_error.code,
                        "error_severity": service_error.severity.value,
                        "error_category": service_error.category.value,
                        "context": context
                    }
                )
        except Exception as handling_error:
            # Fallback error handling
            print(f"Critical error in error handling: {handling_error}")
    
    def implement_circuit_breaker(self, service_name: str, failure_threshold: int = 5) -> CircuitBreaker:
        """Implement circuit breaker for external service calls"""
        return CircuitBreaker(
            service_name=service_name,
            failure_threshold=failure_threshold,
            recovery_timeout=30,
            on_failure=lambda error: self.emit('circuit_breaker_open', {'service': service_name, 'error': error})
        )
    
    def graceful_degradation(self, primary_function, fallback_function, context: str = "operation"):
        """Implement graceful degradation pattern"""
        try:
            return primary_function()
        except Exception as error:
            self.handle_service_error(error, {"context": context, "degradation": "fallback_used"})
            
            # Emit degradation event
            self.emit('service_degradation', {
                'context': context,
                'primary_error': str(error),
                'fallback_activated': True
            })
            
            return fallback_function()

def test_volatility_index():
    """Test the Volatility Index implementation"""
    # Create test data with varying volatility
    np.random.seed(42)
    test_data = []
    base_price = 100.0
    
    for i in range(50):
        # Create periods of varying volatility
        if i < 15:
            vol_factor = 0.5  # Low volatility period
        elif i < 30:
            vol_factor = 2.0  # High volatility period
        else:
            vol_factor = 1.0  # Normal volatility
        
        # Generate price with controlled volatility
        daily_return = np.random.normal(0, 0.01 * vol_factor)
        close_price = base_price * (1 + daily_return)
        
        # Generate realistic OHLC from close
        open_price = close_price * (1 + np.random.normal(0, 0.002))
        range_factor = abs(np.random.normal(0, 0.005 * vol_factor))
        high_price = max(open_price, close_price) * (1 + range_factor)
        low_price = min(open_price, close_price) * (1 - range_factor)
        volume = 1000 + np.random.randint(0, 500)
        test_data.append(MarketData(
            timestamp=datetime.now(),
            open=open_price,
            high=high_price,
            low=low_price,
            close=close_price,
            volume=volume,
            timeframe=TimeFrame.H1
        ))
        
        base_price = close_price  # Update base for next iteration
    
    # Test Volatility Index
    vol_index = VolatilityIndex()
    result = vol_index.calculate(test_data)
    print("=== VOLATILITY INDEX TEST ===")
    print(f"Success: {result.raw_data is None or 'error' not in result.raw_data}")
    if result.raw_data is None or 'error' not in result.raw_data:
        volatility_value = result.value if isinstance(result.value, float) else result.value.get('volatility', 0)
        volatility_values = result.value.get('volatility_values', []) if isinstance(result.value, dict) else []
        regimes = result.value.get('regimes', []) if isinstance(result.value, dict) else []
        
        print(f"Current Volatility: {round(volatility_value, 2)}%")
        if volatility_values:
            print(f"Volatility Values (last 5): {[round(v, 2) for v in volatility_values[-5:]]}")
        if regimes:
            print(f"Current Regime: {regimes[-1]}")
        if result.raw_data:
            print(f"Market Stress Level: {result.raw_data.get('market_stress_level', 'unknown')}")
            print(f"Volatility Method: {result.raw_data.get('method', 'unknown')}")
            print(f"Average Volatility: {round(result.raw_data.get('avg_volatility', 0), 2)}%")
        
        if result.signal:
            print(f"Signal: {result.signal.signal_type.value} - Strength: {result.signal.strength:.2f} - Pattern: {result.signal.metadata.get('pattern', 'N/A')}")
    else:
        print(f"Error: {result.raw_data.get('error', 'Unknown error')}")
    
    return result.raw_data is None or 'error' not in result.raw_data


if __name__ == "__main__":
    test_volatility_index()
