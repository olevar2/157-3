# -*- coding: utf-8 -*-
"""
Relative Strength Index (RSI) Indicator

The RSI is a momentum oscillator that measures the speed and magnitude of price changes.
It oscillates between 0 and 100 and is typically used to identify overbought and oversold conditions.

Key Features:
- Traditional RSI calculation with customizable period
- Multiple smoothing methods (SMA, EMA, WMA)
- Divergence detection capabilities
- Multi-timeframe analysis support
- Overbought/oversold level detection
- Signal generation for trading decisions

Author: Platform3 Analytics Team
Version: 1.0.0
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Union
from dataclasses import dataclass
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class RSISignal(Enum):
    """RSI signal types"""
    OVERSOLD_BOUNCE = "oversold_bounce"
    OVERBOUGHT_REVERSAL = "overbought_reversal"
    BULLISH_DIVERGENCE = "bullish_divergence"
    BEARISH_DIVERGENCE = "bearish_divergence"
    MOMENTUM_SHIFT = "momentum_shift"
    NEUTRAL = "neutral"

class SmoothingMethod(Enum):
    """Smoothing methods for RSI calculation"""
    SMA = "sma"  # Simple Moving Average
    EMA = "ema"  # Exponential Moving Average
    WMA = "wma"  # Weighted Moving Average
    SMMA = "smma"  # Smoothed Moving Average (Wilder's)

@dataclass
class RSIResult:
    """RSI calculation result"""
    rsi_value: float
    signal: RSISignal
    strength: float
    overbought_level: float
    oversold_level: float
    divergence_detected: bool
    momentum_direction: str

class RSI:
    """
    Relative Strength Index (RSI) Technical Indicator
    
    The RSI is a momentum oscillator that compares the magnitude of recent gains
    and losses over a specified time period to measure speed and change of price movements.
    """
    
    def __init__(self,
                 period: int = 14,
                 overbought_level: float = 70.0,
                 oversold_level: float = 30.0,
                 smoothing_method: SmoothingMethod = SmoothingMethod.SMMA):
        """
        Initialize RSI indicator
        
        Args:
            period: Period for RSI calculation (default: 14)
            overbought_level: Overbought threshold (default: 70)
            oversold_level: Oversold threshold (default: 30)
            smoothing_method: Method for smoothing gains/losses
        """
        self.period = period
        self.overbought_level = overbought_level
        self.oversold_level = oversold_level
        self.smoothing_method = smoothing_method
        
        # Historical data for divergence detection
        self.price_history = []
        self.rsi_history = []
        
        logger.info(f"âœ… RSI indicator initialized (period={period}, OB={overbought_level}, OS={oversold_level})")

    def calculate(self, prices: Union[np.ndarray, pd.Series]) -> np.ndarray:
        """
        Calculate RSI values for price series
        
        Args:
            prices: Price data (typically closing prices)
            
        Returns:
            Array of RSI values
        """
        try:
            if isinstance(prices, pd.Series):
                prices = prices.values
            
            if len(prices) < self.period + 1:
                return np.full(len(prices), 50.0)  # Neutral RSI
            
            # Calculate price changes
            price_changes = np.diff(prices)
            
            # Separate gains and losses
            gains = np.where(price_changes > 0, price_changes, 0)
            losses = np.where(price_changes < 0, -price_changes, 0)
            
            # Calculate smoothed gains and losses
            if self.smoothing_method == SmoothingMethod.SMA:
                avg_gains = self._sma(gains, self.period)
                avg_losses = self._sma(losses, self.period)
            elif self.smoothing_method == SmoothingMethod.EMA:
                avg_gains = self._ema(gains, self.period)
                avg_losses = self._ema(losses, self.period)
            elif self.smoothing_method == SmoothingMethod.WMA:
                avg_gains = self._wma(gains, self.period)
                avg_losses = self._wma(losses, self.period)
            else:  # SMMA (Wilder's method)
                avg_gains = self._smma(gains, self.period)
                avg_losses = self._smma(losses, self.period)
            
            # Calculate RS and RSI
            rs = np.divide(avg_gains, avg_losses, out=np.zeros_like(avg_gains), where=avg_losses!=0)
            rsi = 100 - (100 / (1 + rs))
            
            # Handle edge cases
            rsi = np.where(avg_losses == 0, 100, rsi)
            rsi = np.where(avg_gains == 0, 0, rsi)
            
            # Pad with neutral values for initial period
            result = np.full(len(prices), 50.0)
            result[self.period:] = rsi[self.period-1:]
            
            return result
            
        except Exception as e:
            logger.error(f"Error calculating RSI: {e}")
            return np.full(len(prices), 50.0)

    def _sma(self, data: np.ndarray, period: int) -> np.ndarray:
        """Simple Moving Average"""
        return pd.Series(data).rolling(window=period, min_periods=1).mean().values

    def _ema(self, data: np.ndarray, period: int) -> np.ndarray:
        """Exponential Moving Average"""
        return pd.Series(data).ewm(span=period, adjust=False).mean().values

    def _wma(self, data: np.ndarray, period: int) -> np.ndarray:
        """Weighted Moving Average"""
        weights = np.arange(1, period + 1)
        result = np.full(len(data), np.nan)
        
        for i in range(period - 1, len(data)):
            window = data[i - period + 1:i + 1]
            result[i] = np.average(window, weights=weights)
        
        return pd.Series(result).fillna(method='bfill').values

    def _smma(self, data: np.ndarray, period: int) -> np.ndarray:
        """Smoothed Moving Average (Wilder's method)"""
        result = np.full(len(data), np.nan)
        
        # First value is SMA
        if len(data) >= period:
            result[period - 1] = np.mean(data[:period])
            
            # Subsequent values use Wilder's smoothing
            for i in range(period, len(data)):
                result[i] = (result[i - 1] * (period - 1) + data[i]) / period
        
        return pd.Series(result).fillna(method='bfill').values

    def analyze(self, prices: Union[np.ndarray, pd.Series], 
                highs: Optional[np.ndarray] = None,
                lows: Optional[np.ndarray] = None) -> RSIResult:
        """
        Comprehensive RSI analysis with signal generation
        
        Args:
            prices: Price data (typically closing prices)
            highs: High prices for divergence analysis
            lows: Low prices for divergence analysis
            
        Returns:
            RSIResult with comprehensive analysis
        """
        try:
            # Calculate RSI
            rsi_values = self.calculate(prices)
            current_rsi = rsi_values[-1]
            
            # Determine signal
            signal = self._determine_signal(rsi_values, prices, highs, lows)
            
            # Calculate signal strength
            strength = self._calculate_strength(current_rsi)
            
            # Check for divergence
            divergence_detected = self._detect_divergence(rsi_values, prices, highs, lows)
            
            # Determine momentum direction
            momentum_direction = self._get_momentum_direction(rsi_values)
            
            return RSIResult(
                rsi_value=current_rsi,
                signal=signal,
                strength=strength,
                overbought_level=self.overbought_level,
                oversold_level=self.oversold_level,
                divergence_detected=divergence_detected,
                momentum_direction=momentum_direction
            )
            
        except Exception as e:
            logger.error(f"Error in RSI analysis: {e}")
            return RSIResult(50.0, RSISignal.NEUTRAL, 0.0, self.overbought_level, 
                           self.oversold_level, False, "neutral")

    def _determine_signal(self, rsi_values: np.ndarray, prices: np.ndarray,
                         highs: Optional[np.ndarray] = None,
                         lows: Optional[np.ndarray] = None) -> RSISignal:
        """Determine RSI signal based on current conditions"""
        try:
            current_rsi = rsi_values[-1]
            prev_rsi = rsi_values[-2] if len(rsi_values) > 1 else current_rsi
            
            # Check for oversold bounce
            if current_rsi <= self.oversold_level and prev_rsi < current_rsi:
                return RSISignal.OVERSOLD_BOUNCE
            
            # Check for overbought reversal
            if current_rsi >= self.overbought_level and prev_rsi > current_rsi:
                return RSISignal.OVERBOUGHT_REVERSAL
            
            # Check for divergences
            if self._detect_bullish_divergence(rsi_values, prices, lows):
                return RSISignal.BULLISH_DIVERGENCE
            
            if self._detect_bearish_divergence(rsi_values, prices, highs):
                return RSISignal.BEARISH_DIVERGENCE
            
            # Check for momentum shift
            if len(rsi_values) >= 5:
                rsi_trend = np.polyfit(range(5), rsi_values[-5:], 1)[0]
                if abs(rsi_trend) > 2:  # Significant trend change
                    return RSISignal.MOMENTUM_SHIFT
            
            return RSISignal.NEUTRAL
            
        except Exception:
            return RSISignal.NEUTRAL

    def _calculate_strength(self, rsi_value: float) -> float:
        """Calculate signal strength based on RSI value"""
        try:
            if rsi_value >= self.overbought_level:
                # Strength increases as RSI moves further into overbought territory
                strength = min(1.0, (rsi_value - self.overbought_level) / (100 - self.overbought_level))
            elif rsi_value <= self.oversold_level:
                # Strength increases as RSI moves further into oversold territory
                strength = min(1.0, (self.oversold_level - rsi_value) / self.oversold_level)
            else:
                # Neutral zone - strength based on distance from 50
                strength = abs(rsi_value - 50) / 50
            
            return max(0.0, min(1.0, strength))
            
        except Exception:
            return 0.0

    def _detect_divergence(self, rsi_values: np.ndarray, prices: np.ndarray,
                          highs: Optional[np.ndarray] = None,
                          lows: Optional[np.ndarray] = None) -> bool:
        """Detect any type of divergence"""
        try:
            bullish_div = self._detect_bullish_divergence(rsi_values, prices, lows)
            bearish_div = self._detect_bearish_divergence(rsi_values, prices, highs)
            return bullish_div or bearish_div
            
        except Exception:
            return False

    def _detect_bullish_divergence(self, rsi_values: np.ndarray, prices: np.ndarray,
                                  lows: Optional[np.ndarray] = None) -> bool:
        """Detect bullish divergence (price makes lower low, RSI makes higher low)"""
        try:
            if len(rsi_values) < 20:
                return False
            
            price_data = lows if lows is not None else prices
            
            # Find recent lows in both price and RSI
            recent_period = min(20, len(price_data))
            recent_prices = price_data[-recent_period:]
            recent_rsi = rsi_values[-recent_period:]
            
            # Find local minima
            price_lows = self._find_local_minima(recent_prices)
            rsi_lows = self._find_local_minima(recent_rsi)
            
            if len(price_lows) >= 2 and len(rsi_lows) >= 2:
                # Check if price made lower low while RSI made higher low
                latest_price_low = price_lows[-1]
                prev_price_low = price_lows[-2]
                latest_rsi_low = rsi_lows[-1]
                prev_rsi_low = rsi_lows[-2]
                
                price_lower = recent_prices[latest_price_low] < recent_prices[prev_price_low]
                rsi_higher = recent_rsi[latest_rsi_low] > recent_rsi[prev_rsi_low]
                
                return price_lower and rsi_higher
            
            return False
            
        except Exception:
            return False

    def _detect_bearish_divergence(self, rsi_values: np.ndarray, prices: np.ndarray,
                                  highs: Optional[np.ndarray] = None) -> bool:
        """Detect bearish divergence (price makes higher high, RSI makes lower high)"""
        try:
            if len(rsi_values) < 20:
                return False
            
            price_data = highs if highs is not None else prices
            
            # Find recent highs in both price and RSI
            recent_period = min(20, len(price_data))
            recent_prices = price_data[-recent_period:]
            recent_rsi = rsi_values[-recent_period:]
            
            # Find local maxima
            price_highs = self._find_local_maxima(recent_prices)
            rsi_highs = self._find_local_maxima(recent_rsi)
            
            if len(price_highs) >= 2 and len(rsi_highs) >= 2:
                # Check if price made higher high while RSI made lower high
                latest_price_high = price_highs[-1]
                prev_price_high = price_highs[-2]
                latest_rsi_high = rsi_highs[-1]
                prev_rsi_high = rsi_highs[-2]
                
                price_higher = recent_prices[latest_price_high] > recent_prices[prev_price_high]
                rsi_lower = recent_rsi[latest_rsi_high] < recent_rsi[prev_rsi_high]
                
                return price_higher and rsi_lower
            
            return False
            
        except Exception:
            return False

    def _find_local_minima(self, data: np.ndarray, window: int = 3) -> List[int]:
        """Find local minima in data"""
        minima = []
        for i in range(window, len(data) - window):
            if all(data[i] <= data[i-j] for j in range(1, window+1)) and \
               all(data[i] <= data[i+j] for j in range(1, window+1)):
                minima.append(i)
        return minima

    def _find_local_maxima(self, data: np.ndarray, window: int = 3) -> List[int]:
        """Find local maxima in data"""
        maxima = []
        for i in range(window, len(data) - window):
            if all(data[i] >= data[i-j] for j in range(1, window+1)) and \
               all(data[i] >= data[i+j] for j in range(1, window+1)):
                maxima.append(i)
        return maxima

    def _get_momentum_direction(self, rsi_values: np.ndarray) -> str:
        """Determine momentum direction based on RSI trend"""
        try:
            if len(rsi_values) < 3:
                return "neutral"
            
            recent_rsi = rsi_values[-3:]
            trend = np.polyfit(range(len(recent_rsi)), recent_rsi, 1)[0]
            
            if trend > 1:
                return "bullish"
            elif trend < -1:
                return "bearish"
            else:
                return "neutral"
                
        except Exception:
            return "neutral"

    def get_trading_signals(self, prices: Union[np.ndarray, pd.Series],
                           highs: Optional[np.ndarray] = None,
                           lows: Optional[np.ndarray] = None) -> Dict:
        """
        Get comprehensive trading signals based on RSI analysis
        
        Returns:
            Dictionary with trading recommendations
        """
        try:
            analysis = self.analyze(prices, highs, lows)
            rsi_values = self.calculate(prices)
            
            signals = {
                'primary_signal': analysis.signal.value,
                'signal_strength': analysis.strength,
                'rsi_value': analysis.rsi_value,
                'momentum_direction': analysis.momentum_direction,
                'divergence_detected': analysis.divergence_detected,
                'overbought': analysis.rsi_value >= self.overbought_level,
                'oversold': analysis.rsi_value <= self.oversold_level,
                'recommendations': self._generate_recommendations(analysis, rsi_values)
            }
            
            return signals
            
        except Exception as e:
            logger.error(f"Error generating trading signals: {e}")
            return {'primary_signal': 'neutral', 'signal_strength': 0.0}

    def _generate_recommendations(self, analysis: RSIResult, rsi_values: np.ndarray) -> List[str]:
        """Generate trading recommendations based on RSI analysis"""
        recommendations = []
        
        try:
            if analysis.signal == RSISignal.OVERSOLD_BOUNCE:
                recommendations.append("Consider long position - RSI oversold bounce detected")
            elif analysis.signal == RSISignal.OVERBOUGHT_REVERSAL:
                recommendations.append("Consider short position - RSI overbought reversal detected")
            elif analysis.signal == RSISignal.BULLISH_DIVERGENCE:
                recommendations.append("Strong buy signal - Bullish divergence detected")
            elif analysis.signal == RSISignal.BEARISH_DIVERGENCE:
                recommendations.append("Strong sell signal - Bearish divergence detected")
            elif analysis.signal == RSISignal.MOMENTUM_SHIFT:
                if analysis.momentum_direction == "bullish":
                    recommendations.append("Momentum shifting bullish - Consider long positions")
                elif analysis.momentum_direction == "bearish":
                    recommendations.append("Momentum shifting bearish - Consider short positions")
            
            # Additional recommendations based on RSI level
            if analysis.rsi_value > 80:
                recommendations.append("Extreme overbought - High probability of reversal")
            elif analysis.rsi_value < 20:
                recommendations.append("Extreme oversold - High probability of bounce")
            elif 45 <= analysis.rsi_value <= 55:
                recommendations.append("RSI neutral - Wait for clearer signals")
            
            return recommendations
            
        except Exception:
            return ["Unable to generate recommendations"]
