"""
Percentage Price Oscillator (PPO) - Momentum Indicator
Shows the percentage difference between two moving averages.
Similar to MACD but expressed as a percentage, making it easier to compare across different price levels.
"""

from typing import List, Dict, Any, Optional
import numpy as np
import pandas as pd
from dataclasses import dataclass
from ..indicator_base import BaseIndicator, IndicatorResult, IndicatorSignal, SignalType, IndicatorType, MarketData

# Platform3 Winston-style Logging Integration
import sys
import os

# Platform3 Error Handling Integration
from shared.error_handling.platform3_error_system import ServiceError, EventEmitter, CircuitBreaker, ErrorSeverity, ErrorCategory
from shared.error_handling.base_service import BaseService

sys.path.append(os.path.join(os.path.dirname(__file__), '../../shared'))
from logging.platform3_logger import Platform3Logger, log_performance, LogMetadata


@dataclass
class PPOConfig, BaseService:
    """Configuration for Percentage Price Oscillator"""
    fast_period: int = 12
    slow_period: int = 26
    signal_period: int = 9
    price_type: str = 'close'  # 'close', 'high', 'low', 'hl2', 'hlc3', 'ohlc4'
    smoothing_factor: float = 2.0  # For EMA calculation
    signal_threshold: float = 0.05  # Minimum percentage for signal generation


class PercentagePriceOscillator(BaseIndicator):
    """
    Percentage Price Oscillator Implementation
    
    PPO = ((Fast EMA - Slow EMA) / Slow EMA) * 100
    PPO Signal = EMA of PPO over signal period
    PPO Histogram = PPO - PPO Signal
    
    The PPO normalizes the MACD by expressing it as a percentage,
    making it useful for comparing securities with different price levels.
    """
    
    def __init__(self, config: Optional[PPOConfig] = None):
        super().__init__(IndicatorType.MOMENTUM)
        self.config = config or PPOConfig()
        self.ppo_values: List[float] = []
        self.signal_values: List[float] = []
        self.histogram_values: List[float] = []
        self.fast_ema: List[float] = []
        self.slow_ema: List[float] = []
        
    def calculate(self, data: List[MarketData]) -> IndicatorResult:
        try:
        """Calculate Percentage Price Oscillator values"""
        try:
            if len(data) < self.config.slow_period + self.config.signal_period:
                return IndicatorResult(
                    success=False,
                    error=f"Insufficient data: need {self.config.slow_period + self.config.signal_period}, got {len(data)}"
                )
            
            # Extract prices
            prices = self._extract_prices(data, self.config.price_type)
            
            # Calculate EMAs
            fast_ema = self._calculate_ema(prices, self.config.fast_period, self.config.smoothing_factor)
            slow_ema = self._calculate_ema(prices, self.config.slow_period, self.config.smoothing_factor)
            
            # Calculate PPO values
            ppo_values = []
            for i in range(len(slow_ema)):
                if i < len(fast_ema) and slow_ema[i] != 0:
                    ppo = ((fast_ema[i] - slow_ema[i]) / slow_ema[i]) * 100
                    ppo_values.append(ppo)
                else:
                    ppo_values.append(0.0)
            
            # Calculate PPO Signal (EMA of PPO)
            signal_values = self._calculate_ema(ppo_values, self.config.signal_period, self.config.smoothing_factor)
            
            # Calculate PPO Histogram
            histogram_values = []
            for i in range(len(signal_values)):
                if i < len(ppo_values):
                    histogram = ppo_values[i] - signal_values[i]
                    histogram_values.append(histogram)
                else:
                    histogram_values.append(0.0)
            
            # Store values for signal generation
            self.ppo_values = ppo_values
            self.signal_values = signal_values
            self.histogram_values = histogram_values
            self.fast_ema = fast_ema
            self.slow_ema = slow_ema
            
            # Generate signals
            signals = self._generate_signals(data, ppo_values, signal_values, histogram_values)
            
            # Calculate momentum strength
            momentum_strength = self._calculate_momentum_strength(ppo_values, histogram_values)
            
            return IndicatorResult(
                success=True,
                values={
                    'ppo': ppo_values,
                    'signal': signal_values,
                    'histogram': histogram_values,
                    'fast_ema': fast_ema,
                    'slow_ema': slow_ema
                },
                signals=signals,
                metadata={
                    'fast_period': self.config.fast_period,
                    'slow_period': self.config.slow_period,
                    'signal_period': self.config.signal_period,
                    'current_ppo': ppo_values[-1] if ppo_values else 0,
                    'current_signal': signal_values[-1] if signal_values else 0,
                    'current_histogram': histogram_values[-1] if histogram_values else 0,
                    'momentum_strength': momentum_strength,
                    'trend_direction': self._get_trend_direction(ppo_values, signal_values),
                    'momentum_phase': self._get_momentum_phase(histogram_values)
                }
            )
            
        except Exception as e:
            return IndicatorResult(
                success=False,
                error=f"PPO calculation failed: {str(e)}"
            )
    
    def _extract_prices(self, data: List[MarketData], price_type: str) -> List[float]:
        try:
        """Extract prices based on specified type"""
        if price_type == 'close':
            return [candle.close for candle in data]
        elif price_type == 'high':
            return [candle.high for candle in data]
        elif price_type == 'low':
            return [candle.low for candle in data]
        elif price_type == 'hl2':
            return [(candle.high + candle.low) / 2 for candle in data]
        elif price_type == 'hlc3':
            return [(candle.high + candle.low + candle.close) / 3 for candle in data]
        elif price_type == 'ohlc4':
            return [(candle.open + candle.high + candle.low + candle.close) / 4 for candle in data]
        else:
            return [candle.close for candle in data]
    
    def _calculate_ema(self, values: List[float], period: int, smoothing: float) -> List[float]:
        try:
        """Calculate Exponential Moving Average"""
        if not values or period <= 0:
            return []
        
        ema_values = []
        multiplier = smoothing / (period + 1)
        
        # First EMA value is SMA
        if len(values) >= period:
            sma = sum(values[:period]) / period
            ema_values.append(sma)
            
            # Calculate subsequent EMA values
            for i in range(period, len(values)):
                ema = (values[i] * multiplier) + (ema_values[-1] * (1 - multiplier))
                ema_values.append(ema)
        
        return ema_values
    
    def _calculate_momentum_strength(self, ppo_values: List[float], histogram_values: List[float]) -> float:
        try:
        """Calculate overall momentum strength"""
        if not ppo_values or not histogram_values:
            return 0.0
        
        # Use recent values for strength calculation
        recent_ppo = ppo_values[-10:] if len(ppo_values) >= 10 else ppo_values
        recent_histogram = histogram_values[-10:] if len(histogram_values) >= 10 else histogram_values
        
        # Combine PPO magnitude and histogram consistency
        ppo_strength = abs(np.mean(recent_ppo)) if recent_ppo else 0
        histogram_consistency = 1.0 - (np.std(recent_histogram) / (abs(np.mean(recent_histogram)) + 0.001))
        
        # Normalize to 0-1 range
        strength = min((ppo_strength * histogram_consistency) / 2, 1.0)
        return max(strength, 0.0)
    
    def _get_trend_direction(self, ppo_values: List[float], signal_values: List[float]) -> str:
        try:
        """Determine trend direction based on PPO and signal relationship"""
        if not ppo_values or not signal_values:
            return 'neutral'
        
        current_ppo = ppo_values[-1]
        current_signal = signal_values[-1]
        
        if current_ppo > current_signal > 0:
            return 'strong_bullish'
        elif current_ppo > 0 > current_signal:
            return 'bullish'
        elif current_ppo < current_signal < 0:
            return 'strong_bearish'
        elif current_ppo < 0 < current_signal:
            return 'bearish'
        else:
            return 'neutral'
    
    def _get_momentum_phase(self, histogram_values: List[float]) -> str:
        try:
        """Identify momentum phase based on histogram pattern"""
        if len(histogram_values) < 3:
            return 'unknown'
        
        recent = histogram_values[-3:]
        
        # Analyze histogram trend
        if all(recent[i] >= recent[i-1] for i in range(1, len(recent))):
            return 'accelerating' if recent[-1] > 0 else 'recovery'
        elif all(recent[i] <= recent[i-1] for i in range(1, len(recent))):
            return 'decelerating' if recent[-1] > 0 else 'declining'
        else:
            return 'choppy'
    
    def _generate_signals(self, data: List[MarketData], ppo_values: List[float], 
        try:
                         signal_values: List[float], histogram_values: List[float]) -> List[IndicatorSignal]:
        """Generate trading signals based on PPO analysis"""
        signals = []
        
        if len(ppo_values) < 3 or len(signal_values) < 3 or len(histogram_values) < 3:
            return signals
        
        # PPO-Signal crossover signals
        self._detect_ppo_signal_crossover(ppo_values, signal_values, signals)
        
        # Zero line crossover signals
        self._detect_zero_line_crossover(ppo_values, signals)
        
        # Histogram reversal signals
        self._detect_histogram_reversal(histogram_values, signals)
        
        # Divergence signals
        self._detect_divergence(data, ppo_values, signals)
        
        # Momentum acceleration signals
        self._detect_momentum_acceleration(histogram_values, signals)
        
        return signals
    
    def _detect_ppo_signal_crossover(self, ppo_values: List[float], signal_values: List[float], 
        try:
                                   signals: List[IndicatorSignal]):
        """Detect PPO and Signal line crossover"""
        if len(ppo_values) < 2 or len(signal_values) < 2:
            return
        
        current_ppo = ppo_values[-1]
        previous_ppo = ppo_values[-2]
        current_signal = signal_values[-1]
        previous_signal = signal_values[-2]
        
        # Bullish crossover (PPO crosses above Signal)
        if previous_ppo <= previous_signal and current_ppo > current_signal:
            crossover_strength = abs(current_ppo - current_signal)
            if crossover_strength >= self.config.signal_threshold:
                signals.append(IndicatorSignal(
                    signal_type=SignalType.BUY,
                    strength=0.8,
                    confidence=0.75,
                    metadata={
                        'pattern': 'ppo_signal_crossover_bullish',
                        'ppo_value': current_ppo,
                        'signal_value': current_signal,
                        'crossover_strength': crossover_strength
                    }
                ))
        
        # Bearish crossover (PPO crosses below Signal)
        elif previous_ppo >= previous_signal and current_ppo < current_signal:
            crossover_strength = abs(current_ppo - current_signal)
            if crossover_strength >= self.config.signal_threshold:
                signals.append(IndicatorSignal(
                    signal_type=SignalType.SELL,
                    strength=0.8,
                    confidence=0.75,
                    metadata={
                        'pattern': 'ppo_signal_crossover_bearish',
                        'ppo_value': current_ppo,
                        'signal_value': current_signal,
                        'crossover_strength': crossover_strength
                    }
                ))
    
    def _detect_zero_line_crossover(self, ppo_values: List[float], signals: List[IndicatorSignal]):
        try:
        """Detect PPO zero line crossover"""
        if len(ppo_values) < 2:
            return
        
        current = ppo_values[-1]
        previous = ppo_values[-2]
        
        # Bullish zero line crossover
        if previous <= 0 < current and abs(current) >= self.config.signal_threshold:
            signals.append(IndicatorSignal(
                signal_type=SignalType.BUY,
                strength=0.7,
                confidence=0.8,
                metadata={
                    'pattern': 'ppo_zero_crossover_bullish',
                    'ppo_value': current,
                    'momentum_shift': 'positive'
                }
            ))
        
        # Bearish zero line crossover
        elif previous >= 0 > current and abs(current) >= self.config.signal_threshold:
            signals.append(IndicatorSignal(
                signal_type=SignalType.SELL,
                strength=0.7,
                confidence=0.8,
                metadata={
                    'pattern': 'ppo_zero_crossover_bearish',
                    'ppo_value': current,
                    'momentum_shift': 'negative'
                }
            ))
    
    def _detect_histogram_reversal(self, histogram_values: List[float], signals: List[IndicatorSignal]):
        try:
        """Detect histogram reversal patterns"""
        if len(histogram_values) < 3:
            return
        
        h1, h2, h3 = histogram_values[-3], histogram_values[-2], histogram_values[-1]
        
        # Bullish reversal (histogram stops declining and starts rising)
        if h1 < h2 and h2 > h3 and h3 > h2:  # V-shaped bottom
            signals.append(IndicatorSignal(
                signal_type=SignalType.BUY,
                strength=0.6,
                confidence=0.7,
                metadata={
                    'pattern': 'histogram_reversal_bullish',
                    'histogram_value': h3,
                    'reversal_strength': h3 - h2
                }
            ))
        
        # Bearish reversal (histogram stops rising and starts declining)
        elif h1 > h2 and h2 < h3 and h3 < h2:  # Inverted V-shaped top
            signals.append(IndicatorSignal(
                signal_type=SignalType.SELL,
                strength=0.6,
                confidence=0.7,
                metadata={
                    'pattern': 'histogram_reversal_bearish',
                    'histogram_value': h3,
                    'reversal_strength': h2 - h3
                }
            ))
    
    def _detect_divergence(self, data: List[MarketData], ppo_values: List[float], signals: List[IndicatorSignal]):
        try:
        """Detect price-PPO divergences"""
        if len(data) < 10 or len(ppo_values) < 10:
            return
        
        # Extract recent prices and PPO values
        recent_data = data[-10:]
        recent_ppo = ppo_values[-10:]
        prices = [candle.close for candle in recent_data]
        
        # Find recent highs and lows
        price_highs = self._find_peaks(prices, True)
        price_lows = self._find_peaks(prices, False)
        ppo_highs = self._find_peaks(recent_ppo, True)
        ppo_lows = self._find_peaks(recent_ppo, False)
        
        # Bullish divergence (price lower low, PPO higher low)
        if len(price_lows) >= 2 and len(ppo_lows) >= 2:
            if price_lows[-1] < price_lows[-2] and ppo_lows[-1] > ppo_lows[-2]:
                signals.append(IndicatorSignal(
                    signal_type=SignalType.BUY,
                    strength=0.75,
                    confidence=0.7,
                    metadata={
                        'pattern': 'ppo_bullish_divergence',
                        'price_trend': 'lower_low',
                        'ppo_trend': 'higher_low'
                    }
                ))
        
        # Bearish divergence (price higher high, PPO lower high)
        if len(price_highs) >= 2 and len(ppo_highs) >= 2:
            if price_highs[-1] > price_highs[-2] and ppo_highs[-1] < ppo_highs[-2]:
                signals.append(IndicatorSignal(
                    signal_type=SignalType.SELL,
                    strength=0.75,
                    confidence=0.7,
                    metadata={
                        'pattern': 'ppo_bearish_divergence',
                        'price_trend': 'higher_high',
                        'ppo_trend': 'lower_high'
                    }
                ))
    
    def _detect_momentum_acceleration(self, histogram_values: List[float], signals: List[IndicatorSignal]):
        try:
        """Detect momentum acceleration based on histogram"""
        if len(histogram_values) < 5:
            return
        
        recent = histogram_values[-5:]
        
        # Calculate acceleration (second derivative)
        changes = [recent[i] - recent[i-1] for i in range(1, len(recent))]
        acceleration = [changes[i] - changes[i-1] for i in range(1, len(changes))]
        
        if len(acceleration) >= 2:
            current_accel = acceleration[-1]
            
            # Strong positive acceleration
            if current_accel > 0 and recent[-1] > recent[-2]:
                signals.append(IndicatorSignal(
                    signal_type=SignalType.BUY,
                    strength=0.5,
                    confidence=0.6,
                    metadata={
                        'pattern': 'momentum_acceleration_bullish',
                        'acceleration': current_accel,
                        'histogram_trend': 'increasing'
                    }
                ))
            
            # Strong negative acceleration
            elif current_accel < 0 and recent[-1] < recent[-2]:
                signals.append(IndicatorSignal(
                    signal_type=SignalType.SELL,
                    strength=0.5,
                    confidence=0.6,
                    metadata={
                        'pattern': 'momentum_acceleration_bearish',
                        'acceleration': current_accel,
                        'histogram_trend': 'decreasing'
                    }
                ))
    
    def _find_peaks(self, values: List[float], find_max: bool = True) -> List[float]:
        try:
        """Find local peaks (max or min) in the values"""
        peaks = []
        for i in range(1, len(values) - 1):
            if find_max:
                if values[i] > values[i-1] and values[i] > values[i+1]:
                    peaks.append(values[i])
            else:
                if values[i] < values[i-1] and values[i] < values[i+1]:
                    peaks.append(values[i])
        return peaks



    def handle_service_error(self, error: Exception, context: Dict[str, Any] = None) -> None:
        """Handle service errors with proper event emission and logging"""
        try:
            service_error = ServiceError(
                message=str(error),
                code=f"{self.__class__.__name__.upper()}_ERROR",
                metadata={
                    "file_path": "engines/momentum/percentage_price_oscillator.py",
                    "context": context or {},
                    "timestamp": pd.Timestamp.now().isoformat(),
                    "service_name": self.__class__.__name__
                }
            )
            
            # Emit error event for monitoring
            self.emit('error', service_error)
            
            # Log error with correlation context
            if hasattr(self, 'logger'):
                self.logger.error(
                    f"Service error in {self.__class__.__name__}: {str(error)}",
                    extra={
                        "error_code": service_error.code,
                        "error_severity": service_error.severity.value,
                        "error_category": service_error.category.value,
                        "context": context
                    }
                )
        except Exception as handling_error:
            # Fallback error handling
            print(f"Critical error in error handling: {handling_error}")
    
    def implement_circuit_breaker(self, service_name: str, failure_threshold: int = 5) -> CircuitBreaker:
        """Implement circuit breaker for external service calls"""
        return CircuitBreaker(
            service_name=service_name,
            failure_threshold=failure_threshold,
            recovery_timeout=30,
            on_failure=lambda error: self.emit('circuit_breaker_open', {'service': service_name, 'error': error})
        )
    
    def graceful_degradation(self, primary_function, fallback_function, context: str = "operation"):
        """Implement graceful degradation pattern"""
        try:
            return primary_function()
        except Exception as error:
            self.handle_service_error(error, {"context": context, "degradation": "fallback_used"})
            
            # Emit degradation event
            self.emit('service_degradation', {
                'context': context,
                'primary_error': str(error),
                'fallback_activated': True
            })
            
            return fallback_function()

def test_percentage_price_oscillator():
    """Test the Percentage Price Oscillator implementation"""
    # Create test data with trend and momentum changes
    np.random.seed(42)
    test_data = []
    base_price = 100.0
    
    for i in range(80):
        # Generate data with varying momentum
        if i < 30:
            trend = 0.2  # Strong uptrend
        elif i < 50:
            trend = -0.1  # Downtrend
        else:
            trend = 0.05  # Weak uptrend
        
        momentum = np.sin(i * 0.1) * 0.5
        noise = np.random.normal(0, 0.3)
        
        close_price = base_price + trend + momentum + noise
        open_price = close_price + np.random.normal(0, 0.2)
        high_price = max(open_price, close_price) + abs(np.random.normal(0, 0.2))
        low_price = min(open_price, close_price) - abs(np.random.normal(0, 0.2))
        volume = 1000 + np.random.randint(0, 500)
        
        test_data.append(MarketData(
            timestamp=i,
            open=open_price,
            high=high_price,
            low=low_price,
            close=close_price,
            volume=volume
        ))
        
        base_price = close_price
    
    # Test PPO
    ppo = PercentagePriceOscillator()
    result = ppo.calculate(test_data)
    
    print("=== PERCENTAGE PRICE OSCILLATOR TEST ===")
    print(f"Success: {result.success}")
    if result.success:
        ppo_values = result.values['ppo']
        signal_values = result.values['signal']
        histogram_values = result.values['histogram']
        
        print(f"PPO Values (last 5): {[round(v, 4) for v in ppo_values[-5:]]}")
        print(f"Signal Values (last 5): {[round(v, 4) for v in signal_values[-5:]]}")
        print(f"Histogram Values (last 5): {[round(v, 4) for v in histogram_values[-5:]]}")
        print(f"Current PPO: {round(ppo_values[-1], 4)}%")
        print(f"Trend Direction: {result.metadata['trend_direction']}")
        print(f"Momentum Phase: {result.metadata['momentum_phase']}")
        print(f"Momentum Strength: {round(result.metadata['momentum_strength'], 3)}")
        print(f"Number of signals: {len(result.signals)}")
        
        for i, signal in enumerate(result.signals[-3:]):  # Show last 3 signals
            print(f"Signal {i+1}: {signal.signal_type.value} - Strength: {signal.strength:.2f} - {signal.metadata.get('pattern', 'N/A')}")
    else:
        print(f"Error: {result.error}")
    
    return result.success


if __name__ == "__main__":
    test_percentage_price_oscillator()
