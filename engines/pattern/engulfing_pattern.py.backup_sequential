# -*- coding: utf-8 -*-
"""
Engulfing Pattern Scanner - Japanese Candlestick Pattern Recognition
Platform3 Enhanced Technical Analysis Engine

Detects Bullish and Bearish Engulfing patterns, which are powerful two-candle
reversal patterns in technical analysis. An engulfing pattern occurs when
a larger candle completely "engulfs" the previous smaller candle.

Pattern Characteristics:
- Two-candle pattern
- Second candle's body completely engulfs the first candle's body
- Opposite colors (bullish after bearish or vice versa)
- Trend reversal indication

Key Features:
- Bullish and bearish engulfing detection
- Trend context analysis
- Volume confirmation
- Pattern strength measurement
- Reversal probability scoring
- Support/resistance level validation

Trading Applications:
- Trend reversal identification
- Entry/exit timing optimization
- Confirmation of support/resistance levels
- Risk management enhancement
- Market sentiment analysis

Mathematical Foundation:
- Engulfing Condition: Body2_Size > Body1_Size AND Body2 contains Body1
- Volume Confirmation: Volume2 > Average_Volume
- Trend Context: Direction of preceding trend
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Union
from dataclasses import dataclass
from enum import Enum
import logging

from ..indicator_base import IndicatorBase, IndicatorResult

class EngulfingType(Enum):
    """Types of Engulfing patterns"""
    BULLISH_ENGULFING = "bullish_engulfing"
    BEARISH_ENGULFING = "bearish_engulfing"
    NO_PATTERN = "no_pattern"

class EngulfingSignal(Enum):
    """Engulfing signal types"""
    STRONG_BULLISH_REVERSAL = "strong_bullish_reversal"
    STRONG_BEARISH_REVERSAL = "strong_bearish_reversal"
    BULLISH_REVERSAL = "bullish_reversal"
    BEARISH_REVERSAL = "bearish_reversal"
    TREND_CONTINUATION = "trend_continuation"
    NEUTRAL = "neutral"

@dataclass
class CandlestickData:
    """Individual candlestick data"""
    open: float
    high: float
    low: float
    close: float
    volume: float
    body_size: float
    is_bullish: bool
    
@dataclass
class EngulfingPatternResult(IndicatorResult):
    """Engulfing Pattern detection result"""
    pattern_type: EngulfingType
    pattern_strength: float  # 0-100, higher means stronger pattern
    engulfing_ratio: float  # How much larger the engulfing candle is
    first_candle: CandlestickData
    second_candle: CandlestickData
    trend_context: str  # 'uptrend', 'downtrend', 'sideways'
    reversal_probability: float  # 0-100
    volume_confirmation: bool
    volume_ratio: float  # Current volume vs average
    support_resistance_level: Optional[float]
    signal: EngulfingSignal
    signal_strength: float
    
    def to_dict(self) -> Dict:
        """Convert result to dictionary"""
        result_dict = super().to_dict()
        result_dict.update({
            'pattern_type': self.pattern_type.value,
            'pattern_strength': self.pattern_strength,
            'engulfing_ratio': self.engulfing_ratio,
            'first_candle': {
                'open': self.first_candle.open,
                'high': self.first_candle.high,
                'low': self.first_candle.low,
                'close': self.first_candle.close,
                'volume': self.first_candle.volume,
                'body_size': self.first_candle.body_size,
                'is_bullish': self.first_candle.is_bullish
            },
            'second_candle': {
                'open': self.second_candle.open,
                'high': self.second_candle.high,
                'low': self.second_candle.low,
                'close': self.second_candle.close,
                'volume': self.second_candle.volume,
                'body_size': self.second_candle.body_size,
                'is_bullish': self.second_candle.is_bullish
            },
            'trend_context': self.trend_context,
            'reversal_probability': self.reversal_probability,
            'volume_confirmation': self.volume_confirmation,
            'volume_ratio': self.volume_ratio,
            'support_resistance_level': self.support_resistance_level,
            'signal': self.signal.value,
            'signal_strength': self.signal_strength
        })
        return result_dict

class EngulfingPatternScanner(IndicatorBase):
    """
    Engulfing Pattern Scanner - Japanese Candlestick Pattern Recognition
    
    Identifies Bullish and Bearish Engulfing patterns with comprehensive analysis
    including trend context, volume confirmation, and reversal probability.
    """
    
    def __init__(self, 
                 min_engulfing_ratio: float = 1.1,
                 trend_period: int = 10,
                 volume_lookback: int = 10,
                 min_body_size_ratio: float = 0.3,
                 support_resistance_tolerance: float = 0.02):
        """
        Initialize Engulfing Pattern Scanner
        
        Args:
            min_engulfing_ratio: Minimum ratio for engulfing body size (default: 1.1)
            trend_period: Period for trend context analysis (default: 10)
            volume_lookback: Period for volume confirmation (default: 10)
            min_body_size_ratio: Minimum body size relative to range (default: 0.3)
            support_resistance_tolerance: Tolerance for S/R level detection (default: 2%)
        """
        super().__init__("Engulfing Pattern Scanner")
        self.min_engulfing_ratio = min_engulfing_ratio
        self.trend_period = trend_period
        self.volume_lookback = volume_lookback
        self.min_body_size_ratio = min_body_size_ratio
        self.support_resistance_tolerance = support_resistance_tolerance
        
        # Validation
        if self.min_engulfing_ratio < 1:
            raise ValueError("Minimum engulfing ratio must be >= 1")
        if self.trend_period < 3:
            raise ValueError("Trend period must be >= 3")
        if self.volume_lookback < 2:
            raise ValueError("Volume lookback must be >= 2")
        if not 0 < self.min_body_size_ratio < 1:
            raise ValueError("Minimum body size ratio must be between 0 and 1")
            
        # State variables
        self.reset()
        
    def reset(self) -> None:
        """Reset indicator state"""
        super().reset()
        self.candles = []
        self.patterns = []
        
    def _create_candlestick_data(self, open_price: float, high: float, low: float, 
                                close: float, volume: float) -> CandlestickData:
        """Create candlestick data object"""
        body_size = abs(close - open_price)
        is_bullish = close > open_price
        
        return CandlestickData(
            open=open_price,
            high=high,
            low=low,
            close=close,
            volume=volume,
            body_size=body_size,
            is_bullish=is_bullish
        )
    
    def _is_valid_engulfing_pattern(self, first_candle: CandlestickData, 
                                   second_candle: CandlestickData) -> Tuple[bool, EngulfingType]:
        """Check if two candles form a valid engulfing pattern"""
        # Check for minimum body sizes
        first_range = first_candle.high - first_candle.low
        second_range = second_candle.high - second_candle.low
        
        if first_range == 0 or second_range == 0:
            return False, EngulfingType.NO_PATTERN
            
        first_body_ratio = first_candle.body_size / first_range
        second_body_ratio = second_candle.body_size / second_range
        
        if (first_body_ratio < self.min_body_size_ratio or 
            second_body_ratio < self.min_body_size_ratio):
            return False, EngulfingType.NO_PATTERN
        
        # Check for opposite colors
        if first_candle.is_bullish == second_candle.is_bullish:
            return False, EngulfingType.NO_PATTERN
            
        # Check engulfing condition
        engulfing_ratio = second_candle.body_size / first_candle.body_size
        if engulfing_ratio < self.min_engulfing_ratio:
            return False, EngulfingType.NO_PATTERN
            
        # Check if second candle's body completely engulfs first candle's body
        first_body_top = max(first_candle.open, first_candle.close)
        first_body_bottom = min(first_candle.open, first_candle.close)
        second_body_top = max(second_candle.open, second_candle.close)
        second_body_bottom = min(second_candle.open, second_candle.close)
        
        body_engulfed = (second_body_top > first_body_top and 
                        second_body_bottom < first_body_bottom)
        
        if not body_engulfed:
            return False, EngulfingType.NO_PATTERN
            
        # Determine pattern type
        if first_candle.is_bullish and not second_candle.is_bullish:
            return True, EngulfingType.BEARISH_ENGULFING
        else:  # first bearish, second bullish
            return True, EngulfingType.BULLISH_ENGULFING
    
    def _calculate_pattern_strength(self, pattern_type: EngulfingType, 
                                   first_candle: CandlestickData,
                                   second_candle: CandlestickData,
                                   engulfing_ratio: float) -> float:
        """Calculate the strength of the engulfing pattern (0-100)"""
        if pattern_type == EngulfingType.NO_PATTERN:
            return 0.0
            
        # Base strength from engulfing ratio
        ratio_strength = min(50, (engulfing_ratio - 1) * 50)
        
        # Strength from body sizes relative to ranges
        first_range = first_candle.high - first_candle.low
        second_range = second_candle.high - second_candle.low
        
        if first_range > 0 and second_range > 0:
            first_body_ratio = first_candle.body_size / first_range
            second_body_ratio = second_candle.body_size / second_range
            
            # Stronger patterns have larger bodies
            body_strength = (first_body_ratio + second_body_ratio) * 25
        else:
            body_strength = 0
            
        # Shadow analysis - engulfing patterns are stronger with smaller shadows
        first_upper_shadow = first_candle.high - max(first_candle.open, first_candle.close)
        first_lower_shadow = min(first_candle.open, first_candle.close) - first_candle.low
        second_upper_shadow = second_candle.high - max(second_candle.open, second_candle.close)
        second_lower_shadow = min(second_candle.open, second_candle.close) - second_candle.low
        
        total_shadows = first_upper_shadow + first_lower_shadow + second_upper_shadow + second_lower_shadow
        total_bodies = first_candle.body_size + second_candle.body_size
        
        if total_bodies > 0:
            shadow_ratio = total_shadows / total_bodies
            shadow_penalty = min(20, shadow_ratio * 10)
        else:
            shadow_penalty = 0
            
        final_strength = ratio_strength + body_strength - shadow_penalty
        return min(100, max(0, final_strength))
    
    def _determine_trend_context(self) -> str:
        """Determine current trend context"""
        if len(self.candles) < self.trend_period:
            return 'sideways'
            
        # Use closing prices for trend analysis
        recent_closes = [candle.close for candle in self.candles[-self.trend_period:]]
        
        # Calculate trend slope using linear regression
        x = np.arange(len(recent_closes))
        slope = np.polyfit(x, recent_closes, 1)[0]
        
        # Normalize slope by price range
        price_range = max(recent_closes) - min(recent_closes)
        relative_slope = slope / price_range if price_range > 0 else 0
        
        # Classify trend
        if relative_slope > 0.1:
            return 'uptrend'
        elif relative_slope < -0.1:
            return 'downtrend'
        else:
            return 'sideways'
    
    def _find_support_resistance_level(self, first_candle: CandlestickData, 
                                      second_candle: CandlestickData) -> Optional[float]:
        """Find nearby support/resistance levels"""
        if len(self.candles) < 5:
            return None
            
        # Get recent highs and lows
        recent_highs = [candle.high for candle in self.candles[-20:]] if len(self.candles) >= 20 else [candle.high for candle in self.candles]
        recent_lows = [candle.low for candle in self.candles[-20:]] if len(self.candles) >= 20 else [candle.low for candle in self.candles]
        
        all_levels = recent_highs + recent_lows
        
        # Pattern price levels
        pattern_high = max(first_candle.high, second_candle.high)
        pattern_low = min(first_candle.low, second_candle.low)
        
        # Find levels near pattern
        tolerance = (pattern_high - pattern_low) * self.support_resistance_tolerance
        
        for level in all_levels:
            if (abs(level - pattern_low) <= tolerance or 
                abs(level - pattern_high) <= tolerance):
                return level
                
        return None
    
    def _calculate_volume_ratio(self, current_volume: float) -> float:
        """Calculate current volume ratio vs average"""
        if len(self.candles) < self.volume_lookback:
            return 1.0
            
        recent_volumes = [candle.volume for candle in self.candles[-self.volume_lookback:]]
        avg_volume = sum(recent_volumes) / len(recent_volumes)
        
        return current_volume / avg_volume if avg_volume > 0 else 1.0
    
    def _calculate_reversal_probability(self, pattern_type: EngulfingType, pattern_strength: float,
                                       trend_context: str, volume_confirmation: bool,
                                       support_resistance_level: Optional[float]) -> float:
        """Calculate probability of trend reversal (0-100)"""
        base_probability = {
            EngulfingType.BULLISH_ENGULFING: 75,
            EngulfingType.BEARISH_ENGULFING: 75,
            EngulfingType.NO_PATTERN: 0
        }.get(pattern_type, 0)
        
        # Adjust for trend context appropriateness
        if pattern_type == EngulfingType.BULLISH_ENGULFING and trend_context == 'downtrend':
            trend_adjustment = 1.3
        elif pattern_type == EngulfingType.BEARISH_ENGULFING and trend_context == 'uptrend':
            trend_adjustment = 1.3
        elif trend_context == 'sideways':
            trend_adjustment = 0.8
        else:
            trend_adjustment = 0.7  # Counter-trend pattern
            
        # Adjust for pattern strength
        strength_adjustment = pattern_strength / 100
        
        # Adjust for volume confirmation
        volume_adjustment = 1.2 if volume_confirmation else 0.85
        
        # Adjust for support/resistance level
        sr_adjustment = 1.15 if support_resistance_level is not None else 1.0
        
        probability = base_probability * trend_adjustment * strength_adjustment * volume_adjustment * sr_adjustment
        return min(100, max(0, probability))
    
    def _generate_signal(self, pattern_type: EngulfingType, reversal_probability: float,
                        trend_context: str, volume_confirmation: bool) -> Tuple[EngulfingSignal, float]:
        """Generate trading signal based on pattern analysis"""
        if pattern_type == EngulfingType.NO_PATTERN:
            return EngulfingSignal.NEUTRAL, 25
            
        # Strong reversal signals
        if reversal_probability > 80 and volume_confirmation:
            if pattern_type == EngulfingType.BULLISH_ENGULFING:
                return EngulfingSignal.STRONG_BULLISH_REVERSAL, reversal_probability
            else:
                return EngulfingSignal.STRONG_BEARISH_REVERSAL, reversal_probability
                
        # Medium reversal signals
        elif reversal_probability > 60:
            if pattern_type == EngulfingType.BULLISH_ENGULFING:
                return EngulfingSignal.BULLISH_REVERSAL, reversal_probability
            else:
                return EngulfingSignal.BEARISH_REVERSAL, reversal_probability
                
        # Low probability - trend continuation more likely
        elif reversal_probability > 30:
            return EngulfingSignal.TREND_CONTINUATION, 100 - reversal_probability
            
        return EngulfingSignal.NEUTRAL, 25
    
    def update(self, open_price: float, high: float, low: float, close: float, 
               volume: float = 0, timestamp: Optional[pd.Timestamp] = None) -> EngulfingPatternResult:
        """
        Update Engulfing Pattern Scanner with new candlestick data
        
        Args:
            open_price: Opening price
            high: High price
            low: Low price
            close: Close price
            volume: Volume (optional)
            timestamp: Optional timestamp
            
        Returns:
            EngulfingPatternResult: Pattern detection result
        """
        try:
            # Create current candlestick
            current_candle = self._create_candlestick_data(open_price, high, low, close, volume)
            self.candles.append(current_candle)
            
            # Initialize default result
            pattern_type = EngulfingType.NO_PATTERN
            pattern_strength = 0.0
            engulfing_ratio = 0.0
            first_candle = current_candle
            second_candle = current_candle
            
            # Check for engulfing pattern (need at least 2 candles)
            if len(self.candles) >= 2:
                first_candle = self.candles[-2]
                second_candle = self.candles[-1]
                
                is_engulfing, pattern_type = self._is_valid_engulfing_pattern(first_candle, second_candle)
                
                if is_engulfing:
                    engulfing_ratio = second_candle.body_size / first_candle.body_size
                    pattern_strength = self._calculate_pattern_strength(
                        pattern_type, first_candle, second_candle, engulfing_ratio
                    )
            
            # Determine trend context
            trend_context = self._determine_trend_context()
            
            # Find support/resistance level
            support_resistance_level = self._find_support_resistance_level(first_candle, second_candle)
            
            # Calculate volume metrics
            volume_ratio = self._calculate_volume_ratio(volume)
            volume_confirmation = volume_ratio > 1.1
            
            # Calculate reversal probability
            reversal_probability = self._calculate_reversal_probability(
                pattern_type, pattern_strength, trend_context, volume_confirmation, support_resistance_level
            )
            
            # Generate signal
            signal, signal_strength = self._generate_signal(
                pattern_type, reversal_probability, trend_context, volume_confirmation
            )
            
            # Create result
            result = EngulfingPatternResult(
                timestamp=timestamp or pd.Timestamp.now(),
                value=pattern_strength,
                pattern_type=pattern_type,
                pattern_strength=pattern_strength,
                engulfing_ratio=engulfing_ratio,
                first_candle=first_candle,
                second_candle=second_candle,
                trend_context=trend_context,
                reversal_probability=reversal_probability,
                volume_confirmation=volume_confirmation,
                volume_ratio=volume_ratio,
                support_resistance_level=support_resistance_level,
                signal=signal,
                signal_strength=signal_strength,
                metadata={
                    'min_engulfing_ratio': self.min_engulfing_ratio,
                    'trend_period': self.trend_period,
                    'volume_lookback': self.volume_lookback,
                    'min_body_size_ratio': self.min_body_size_ratio
                }
            )
            
            self.patterns.append(result)
            self.last_result = result
            return result
            
        except Exception as e:
            self.logger.error(f"Error updating Engulfing Pattern Scanner: {str(e)}")
            raise
    
    def get_recent_patterns(self, lookback: int = 10) -> List[EngulfingPatternResult]:
        """Get recent patterns"""
        return self.patterns[-lookback:] if len(self.patterns) >= lookback else self.patterns
    
    def __str__(self) -> str:
        return f"EngulfingPatternScanner(min_ratio={self.min_engulfing_ratio}, trend_period={self.trend_period})"
