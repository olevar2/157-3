# -*- coding: utf-8 -*-
"""
Chaikin Money Flow (CMF) - Volume-Weighted Momentum Indicator
Platform3 - Humanitarian Trading System

Chaikin Money Flow is a volume-weighted average of the Accumulation/Distribution
Line over a specified period. It oscillates between +1 and -1, measuring the
amount of Money Flow Volume over a given period.

Key Features:
- Volume-weighted momentum measurement
- Oscillator format for easy interpretation
- Buying/selling pressure analysis
- Trend confirmation capabilities
- Divergence detection
- Overbought/oversold identification

Money Flow Multiplier = ((Close - Low) - (High - Close)) / (High - Low)
Money Flow Volume = Money Flow Multiplier multiply Volume
CMF = Sum(Money Flow Volume, n) / Sum(Volume, n)

Humanitarian Mission: Optimize money flow timing for maximum profit generation
through volume-confirmed momentum signals and smart money identification.
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from ..indicator_base import IndicatorSignal, TechnicalIndicator
import logging

logger = logging.getLogger(__name__)

@dataclass
class ChaikinMoneyFlowSignal(IndicatorSignal):
    """CMF-specific signal with detailed analysis"""
    cmf_value: float
    money_flow_volume: float
    volume_sum: float
    pressure_level: str  # "strong_buying", "buying", "neutral", "selling", "strong_selling"
    trend_direction: str  # "bullish", "bearish", "neutral"
    momentum_phase: str  # "accelerating", "decelerating", "stable"
    overbought_oversold: str  # "overbought", "oversold", "neutral"
    zero_line_cross: Optional[str]  # "bullish_cross", "bearish_cross"
    divergence_signal: Optional[str]  # "bullish_divergence", "bearish_divergence"
    volume_quality: str  # "high", "medium", "low"

class ChaikinMoneyFlow(TechnicalIndicator):
    """
    Advanced Chaikin Money Flow Implementation
    
    Measures the amount of money flow volume over a specific period,
    providing insights into buying and selling pressure through volume analysis.
    """
    
    def __init__(self, 
                 period: int = 20,
                 overbought_threshold: float = 0.25,
                 oversold_threshold: float = -0.25,
                 trend_confirmation_period: int = 5,
                 divergence_period: int = 15):
        """
        Initialize CMF with comprehensive analysis parameters
        
        Args:
            period: Calculation period (default 20)
            overbought_threshold: Overbought level (default 0.25)
            oversold_threshold: Oversold level (default -0.25)
            trend_confirmation_period: Periods for trend confirmation
            divergence_period: Period for divergence analysis
        """
        super().__init__()
        self.period = period
        self.overbought_threshold = overbought_threshold
        self.oversold_threshold = oversold_threshold
        self.trend_confirmation_period = trend_confirmation_period
        self.divergence_period = divergence_period
        
        # Historical data storage
        self.highs: List[float] = []
        self.lows: List[float] = []
        self.closes: List[float] = []
        self.volumes: List[float] = []
        self.money_flow_volumes: List[float] = []
        self.cmf_values: List[float] = []
        self.signals: List[ChaikinMoneyFlowSignal] = []
        
    def calculate(self, 
                  high: float, 
                  low: float, 
                  close: float, 
                  volume: float, 
                  timestamp: Optional[Any] = None) -> ChaikinMoneyFlowSignal:
        """
        Calculate CMF with comprehensive volume momentum analysis
        """
        try:
            # Store current values
            self.highs.append(high)
            self.lows.append(low)
            self.closes.append(close)
            self.volumes.append(volume)
            
            # Calculate Money Flow Multiplier
            if high == low:  # Avoid division by zero
                money_flow_multiplier = 0.0
            else:
                money_flow_multiplier = ((close - low) - (high - close)) / (high - low)
            
            # Calculate Money Flow Volume
            money_flow_volume = money_flow_multiplier * volume
            self.money_flow_volumes.append(money_flow_volume)
            
            # Calculate CMF over the specified period
            if len(self.money_flow_volumes) >= self.period:
                # Sum of Money Flow Volume over period
                mfv_sum = sum(self.money_flow_volumes[-self.period:])
                
                # Sum of Volume over period
                volume_sum = sum(self.volumes[-self.period:])
                
                # Calculate CMF
                if volume_sum > 0:
                    cmf_value = mfv_sum / volume_sum
                else:
                    cmf_value = 0.0
            else:
                cmf_value = 0.0
                volume_sum = sum(self.volumes) if self.volumes else 0.0
            
            self.cmf_values.append(cmf_value)
            
            # Limit history
            if len(self.closes) > 200:
                self.highs = self.highs[-200:]
                self.lows = self.lows[-200:]
                self.closes = self.closes[-200:]
                self.volumes = self.volumes[-200:]
                self.money_flow_volumes = self.money_flow_volumes[-200:]
                self.cmf_values = self.cmf_values[-200:]
            
            # Generate comprehensive signal
            signal = self._generate_signal(high, low, close, volume, 
                                           cmf_value, money_flow_volume, volume_sum)
            self.signals.append(signal)
            
            return signal
            
        except Exception as e:
            logger.error(f"CMF calculation error: {e}")
            return self._create_neutral_signal(close, 0.0, 0.0, 0.0)
    
    def _generate_signal(self, high: float, low: float, close: float, volume: float,
                         cmf_value: float, money_flow_volume: float, 
                         volume_sum: float) -> ChaikinMoneyFlowSignal:
        """Generate comprehensive CMF signal with all analysis components"""
        
        # 1. Pressure level analysis
        pressure_level = self._analyze_pressure_level(cmf_value)
        
        # 2. Trend direction analysis
        trend_direction = self._analyze_trend_direction(cmf_value)
        
        # 3. Momentum phase analysis
        momentum_phase = self._analyze_momentum_phase()
        
        # 4. Overbought/oversold analysis
        overbought_oversold = self._analyze_overbought_oversold(cmf_value)
        
        # 5. Zero line crossover analysis
        zero_line_cross = self._analyze_zero_line_cross(cmf_value)
        
        # 6. Divergence analysis
        divergence_signal = self._analyze_divergence()
        
        # 7. Volume quality analysis
        volume_quality = self._analyze_volume_quality(volume)
        
        # 8. Calculate overall signal strength and confidence
        strength, confidence = self._calculate_signal_metrics(
            cmf_value, pressure_level, trend_direction, momentum_phase,
            overbought_oversold, zero_line_cross, divergence_signal, volume_quality
        )
        
        return ChaikinMoneyFlowSignal(
            strength=strength,
            confidence=confidence,
            cmf_value=cmf_value,
            money_flow_volume=money_flow_volume,
            volume_sum=volume_sum,
            pressure_level=pressure_level,
            trend_direction=trend_direction,
            momentum_phase=momentum_phase,
            overbought_oversold=overbought_oversold,
            zero_line_cross=zero_line_cross,
            divergence_signal=divergence_signal,
            volume_quality=volume_quality,
            metadata={
                "indicator": "CMF",
                "period": self.period,
                "volume_weighted": True,
                "oscillator_type": True,
                "analysis_components": {
                    "pressure": pressure_level,
                    "trend": trend_direction,
                    "momentum": momentum_phase,
                    "levels": overbought_oversold,
                    "crossover": zero_line_cross,
                    "divergence": divergence_signal,
                    "volume_quality": volume_quality,
                    "thresholds": {
                        "overbought": self.overbought_threshold,
                        "oversold": self.oversold_threshold
                    }
                }
            }
        )
    
    def _analyze_pressure_level(self, cmf_value: float) -> str:
        """Analyze buying/selling pressure level"""
        
        if cmf_value > 0.4:
            return "strong_buying"
        elif cmf_value > 0.1:
            return "buying"
        elif cmf_value > -0.1:
            return "neutral"
        elif cmf_value > -0.4:
            return "selling"
        else:
            return "strong_selling"
    
    def _analyze_trend_direction(self, cmf_value: float) -> str:
        """Analyze trend direction based on CMF position and movement"""
        
        if len(self.cmf_values) < self.trend_confirmation_period:
            return "neutral"
        
        recent_values = self.cmf_values[-self.trend_confirmation_period:]
        
        # Calculate trend slope
        x = np.arange(len(recent_values))
        slope = np.polyfit(x, recent_values, 1)[0]
        
        # Combine slope with current level
        if cmf_value > 0 and slope > 0:
            return "bullish"
        elif cmf_value < 0 and slope < 0:
            return "bearish"
        elif slope > 0.02:  # Strong positive slope
            return "bullish"
        elif slope < -0.02:  # Strong negative slope
            return "bearish"
        else:
            return "neutral"
    
    def _analyze_momentum_phase(self) -> str:
        """Analyze CMF momentum acceleration/deceleration"""
        if len(self.cmf_values) < 8:
            return "stable"
        
        # Compare recent rate of change to previous rate of change
        recent_values = self.cmf_values[-4:]
        previous_values = self.cmf_values[-8:-4]
        
        # Calculate rate of change for both periods
        recent_slope = np.polyfit(np.arange(len(recent_values)), recent_values, 1)[0]
        previous_slope = np.polyfit(np.arange(len(previous_values)), previous_values, 1)[0]
        
        # Determine acceleration/deceleration
        if abs(recent_slope) > abs(previous_slope) * 1.3:
            return "accelerating"
        elif abs(recent_slope) < abs(previous_slope) * 0.7:
            return "decelerating"
        else:
            return "stable"
    
    def _analyze_overbought_oversold(self, cmf_value: float) -> str:
        """Analyze overbought/oversold conditions"""
        
        if cmf_value >= self.overbought_threshold:
            return "overbought"
        elif cmf_value <= self.oversold_threshold:
            return "oversold"
        else:
            return "neutral"
    
    def _analyze_zero_line_cross(self, cmf_value: float) -> Optional[str]:
        """Analyze zero line crossovers"""
        if len(self.cmf_values) < 2:
            return None
        
        prev_cmf = self.cmf_values[-2]
        
        # Bullish crossover: CMF crosses above zero
        if prev_cmf <= 0 and cmf_value > 0:
            return "bullish_cross"
        
        # Bearish crossover: CMF crosses below zero
        elif prev_cmf >= 0 and cmf_value < 0:
            return "bearish_cross"
        
        return None
    
    def _analyze_divergence(self) -> Optional[str]:
        """Analyze divergence between price and CMF"""
        if (len(self.closes) < self.divergence_period or 
            len(self.cmf_values) < self.divergence_period):
            return None
        
        # Analyze trends in both price and CMF
        price_data = self.closes[-self.divergence_period:]
        cmf_data = self.cmf_values[-self.divergence_period:]
        
        # Calculate slopes
        x = np.arange(len(price_data))
        price_slope = np.polyfit(x, price_data, 1)[0]
        cmf_slope = np.polyfit(x, cmf_data, 1)[0]
        
        # Detect significant divergences
        price_trend_up = price_slope > 0
        cmf_trend_up = cmf_slope > 0
        
        # Check for divergence with minimum significance
        min_price_change = abs(price_data[-1] - price_data[0]) / price_data[0]
        min_cmf_change = abs(cmf_data[-1] - cmf_data[0])
        
        if min_price_change > 0.01 and min_cmf_change > 0.05:
            if price_trend_up and not cmf_trend_up:
                return "bearish_divergence"
            elif not price_trend_up and cmf_trend_up:
                return "bullish_divergence"
        
        return None
    
    def _analyze_volume_quality(self, current_volume: float) -> str:
        """Analyze volume quality for signal confirmation"""
        if len(self.volumes) < 10:
            return "medium"
        
        # Calculate average volume
        avg_volume = np.mean(self.volumes[-10:])
        volume_ratio = current_volume / avg_volume if avg_volume > 0 else 1.0
        
        if volume_ratio >= 1.5:
            return "high"
        elif volume_ratio >= 0.8:
            return "medium"
        else:
            return "low"
    
    def _calculate_signal_metrics(self, cmf_value: float, pressure_level: str,
                                  trend_direction: str, momentum_phase: str,
                                  overbought_oversold: str, zero_line_cross: Optional[str],
                                  divergence_signal: Optional[str], 
                                  volume_quality: str) -> Tuple[float, float]:
        """Calculate overall signal strength and confidence"""
        
        strength = 0.0
        confidence = 0.0
        
        # 1. CMF value contribution (primary signal)
        strength += cmf_value * 0.6  # CMF ranges from -1 to +1
        confidence += abs(cmf_value) * 0.3
        
        # 2. Zero line crossover signals (strong signals)
        if zero_line_cross == "bullish_cross":
            strength += 0.4
            confidence += 0.3
        elif zero_line_cross == "bearish_cross":
            strength -= 0.4
            confidence += 0.3
        
        # 3. Overbought/oversold contribution
        if overbought_oversold == "oversold":
            strength += 0.2  # Potential reversal
            confidence += 0.2
        elif overbought_oversold == "overbought":
            strength -= 0.2  # Potential reversal
            confidence += 0.2
        
        # 4. Divergence signals (important confirmations)
        if divergence_signal == "bullish_divergence":
            strength += 0.3
            confidence += 0.4
        elif divergence_signal == "bearish_divergence":
            strength -= 0.3
            confidence += 0.4
        
        # 5. Trend direction confirmation
        if trend_direction == "bullish" and strength > 0:
            strength *= 1.2
            confidence += 0.1
        elif trend_direction == "bearish" and strength < 0:
            strength *= 1.2
            confidence += 0.1
        
        # 6. Momentum phase adjustment
        if momentum_phase == "accelerating":
            strength *= 1.1
            confidence += 0.1
        elif momentum_phase == "decelerating":
            strength *= 0.9
            confidence -= 0.05
        
        # 7. Volume quality adjustment
        volume_multipliers = {
            "high": 1.2,
            "medium": 1.0,
            "low": 0.8
        }
        
        volume_mult = volume_multipliers.get(volume_quality, 1.0)
        strength *= volume_mult
        confidence *= volume_mult
        
        # 8. Pressure level confidence boost
        pressure_confidence = {
            "strong_buying": 0.2,
            "strong_selling": 0.2,
            "buying": 0.1,
            "selling": 0.1,
            "neutral": 0.0
        }
        
        confidence += pressure_confidence.get(pressure_level, 0.0)
        
        # Normalize
        strength = max(-1.0, min(1.0, strength))
        confidence = max(0.0, min(1.0, confidence))
        
        return strength, confidence
    
    def _create_neutral_signal(self, close: float, cmf_value: float,
                               money_flow_volume: float, 
                               volume_sum: float) -> ChaikinMoneyFlowSignal:
        """Create neutral signal for insufficient data"""
        return ChaikinMoneyFlowSignal(
            strength=0.0,
            confidence=0.0,
            cmf_value=cmf_value,
            money_flow_volume=money_flow_volume,
            volume_sum=volume_sum,
            pressure_level="neutral",
            trend_direction="neutral",
            momentum_phase="stable",
            overbought_oversold="neutral",
            zero_line_cross=None,
            divergence_signal=None,
            volume_quality="medium",
            metadata={
                "indicator": "CMF",
                "status": "insufficient_data"
            }
        )

# Test function
def test_chaikin_money_flow():
    """Test CMF with realistic EURUSD data"""
    print("Testing Chaikin Money Flow...")
    
    # Simulate EURUSD price data with money flow patterns
    np.random.seed(42)
    base_price = 1.1000
    prices = []
    volumes = []
    
    for i in range(100):
        # Create different money flow phases
        if i < 25:
            # Strong buying pressure
            close_bias = 0.8  # Closes near highs
            volume_boost = 1.3
        elif i < 50:
            # Selling pressure
            close_bias = 0.2  # Closes near lows
            volume_boost = 1.1
        elif i < 75:
            # Neutral/mixed flow
            close_bias = 0.5  # Neutral closes
            volume_boost = 1.0
        else:
            # Accumulation phase
            close_bias = 0.7  # Closes above mid-range
            volume_boost = 1.2
        
        # Generate price movement
        volatility = 0.0008
        trend = 0.00005 * i if i < 50 else -0.00002 * (i - 50)
        price = base_price + trend + np.random.normal(0, volatility)
        
        # Generate OHLC with bias toward close position
        range_size = volatility * 3
        low_price = price - range_size * np.random.uniform(0.2, 0.8)
        high_price = price + range_size * np.random.uniform(0.2, 0.8)
        
        # Position close based on bias
        close_position = close_bias + np.random.normal(0, 0.1)
        close_position = max(0.1, min(0.9, close_position))
        close = low_price + (high_price - low_price) * close_position
        
        # Generate volume with boost and noise
        base_volume = 1000000
        volume = base_volume * volume_boost * (1 + np.random.normal(0, 0.2))
        volume = max(500000, volume)
        
        prices.append((high_price, low_price, close))
        volumes.append(volume)
    
    # Test CMF
    cmf = ChaikinMoneyFlow(period=20)
    
    print("\nCMF Test Results:")
    print("-" * 60)
    
    for i, ((high, low, close), volume) in enumerate(zip(prices, volumes)):
        signal = cmf.calculate(high, low, close, volume)
        
        # Print key signals
        if i >= 25 and i % 12 == 0:  # After enough data and every 12th
            print(f"Period {i+1}:")
            print(f"  Price: {close:.5f}")
            print(f"  CMF: {signal.cmf_value:.4f}")
            print(f"  Money Flow Vol: {signal.money_flow_volume:.0f}")
            print(f"  Pressure: {signal.pressure_level}")
            print(f"  Trend: {signal.trend_direction}")
            print(f"  Momentum: {signal.momentum_phase}")
            print(f"  Level: {signal.overbought_oversold}")
            print(f"  Zero Cross: {signal.zero_line_cross}")
            print(f"  Divergence: {signal.divergence_signal}")
            print(f"  Volume Quality: {signal.volume_quality}")
            print(f"  Signal: {signal.strength:.3f} (conf: {signal.confidence:.3f})")
            print()

if __name__ == "__main__":
    test_chaikin_money_flow()
