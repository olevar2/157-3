# 🕯️ Japanese Candlestick Patterns - Comprehensive Implementation
# Platform3 - Maximum Accuracy Humanitarian Trading System

import numpy as np
import numba
import sys
import os
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass

# Add Platform3 logging framework
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', '..', '..', 'shared'))
from logging.platform3_logger import Platform3Logger, log_performance, LogMetadata

@dataclass
class CandleData:
    """Individual candle data structure"""
    open: float
    high: float
    low: float
    close: float
    volume: float
    timestamp: int

@dataclass
class PatternResult:
    """Pattern detection result"""
    pattern_name: str
    pattern_type: str  # 'bullish', 'bearish', 'neutral'
    strength_score: float  # 0-100
    confidence: float  # 0-1
    confirmation_needed: bool
    description: str

class JapaneseCandlestickPatterns:
    """
    Comprehensive Japanese Candlestick Pattern Recognition
    
    Implements 50+ candlestick patterns with:
    - Strength scoring based on context
    - Volume confirmation
    - Multi-timeframe validation
    - Pattern evolution tracking
    """
    
    def __init__(self, request_id: Optional[str] = None, user_id: Optional[str] = None):
        self.logger = Platform3Logger.get_pattern_logger("japanese_candlesticks")
        self.request_id = request_id
        self.user_id = user_id
        
        # Log initialization
        with self.logger.correlation_context(self.request_id, self.user_id):
            self.logger.info(
                "Initializing Japanese Candlestick Pattern Recognition Engine",
                extra={
                    "component": "pattern_recognition",
                    "pattern_count": "50+",
                    "features": ["strength_scoring", "volume_confirmation", "multi_timeframe"]
                }
            )
        
        self.pattern_database = self._initialize_pattern_database()
        self.min_body_size = 0.001  # Minimum body size as % of range
        self.shadow_ratio_threshold = 2.0  # Shadow to body ratio
        
    @log_performance
    def analyze_patterns(self, candles: List[CandleData], context: Dict) -> List[PatternResult]:
        """
        Analyze all candlestick patterns for given candle data
        
        Args:
            candles: List of CandleData objects (minimum 3 candles needed)
            context: Market context including trend, volume averages, support/resistance
            
        Returns:
            List of PatternResult objects for detected patterns
        """
        with self.logger.correlation_context(self.request_id, self.user_id):
            self.logger.debug(
                "Starting pattern analysis",
                extra={
                    "candle_count": len(candles),
                    "analysis_depth": "comprehensive",
                    "context_keys": list(context.keys()) if context else []
                }
            )
            
            if len(candles) < 3:
                self.logger.warning(
                    "Insufficient candles for pattern analysis",
                    extra={"candle_count": len(candles), "minimum_required": 3}
                )
                return []
                
            patterns_detected = []
            
            try:
                # Single candle patterns
                single_patterns = self._analyze_single_candle_patterns(candles[-1], context)
                patterns_detected.extend(single_patterns)
                
                # Two candle patterns
                if len(candles) >= 2:
                    two_patterns = self._analyze_two_candle_patterns(candles[-2:], context)
                    patterns_detected.extend(two_patterns)
                  # Three+ candle patterns
                if len(candles) >= 3:
                    three_patterns = self._analyze_multi_candle_patterns(candles[-3:], context)
                    patterns_detected.extend(three_patterns)
                    
                # Five candle patterns
                if len(candles) >= 5:
                    five_patterns = self._analyze_five_candle_patterns(candles[-5:], context)
                    patterns_detected.extend(five_patterns)
                
                # Log successful analysis
                self.logger.info(
                    "Pattern analysis completed successfully",
                    extra={
                        "patterns_detected": len(patterns_detected),
                        "pattern_types": [p.pattern_name for p in patterns_detected],
                        "high_confidence_patterns": len([p for p in patterns_detected if p.confidence > 0.7])
                    }
                )
                
                return self._rank_and_filter_patterns(patterns_detected)
                
            except Exception as e:
                self.logger.error(
                    "Critical error during pattern analysis",
                    exc_info=e,
                    extra={
                        "candle_count": len(candles),
                        "error_type": type(e).__name__,
                        "component": "pattern_analysis"
                    }
                )
                return []
            
            # Filter and rank patterns by strength
            return self._rank_patterns_by_strength(patterns_detected, context)
      # ================================
    # SINGLE CANDLE PATTERNS (20 Patterns)
    # ================================
    def _analyze_single_candle_patterns(self, candle: CandleData, context: Dict) -> List[PatternResult]:
        """Analyze single candle patterns"""
        with self.logger.correlation_context(self.request_id, self.user_id):
            self.logger.debug(
                "Analyzing single candle patterns",
                extra={
                    "candle_data": {
                        "open": candle.open,
                        "high": candle.high,
                        "low": candle.low,
                        "close": candle.close,
                        "volume": candle.volume
                    }
                }
            )
            
            patterns = []
            
            try:
                # Calculate basic candle metrics
                body_size = abs(candle.close - candle.open)
                upper_shadow = candle.high - max(candle.open, candle.close)
                lower_shadow = min(candle.open, candle.close) - candle.low
                total_range = candle.high - candle.low
                
                if total_range == 0:
                    self.logger.warning("Zero range candle detected", extra={"candle_timestamp": candle.timestamp})
                    return patterns
                    
                body_ratio = body_size / total_range
                upper_shadow_ratio = upper_shadow / body_size if body_size > 0 else float('inf')
                lower_shadow_ratio = lower_shadow / body_size if body_size > 0 else float('inf')
                
                # DOJI FAMILY PATTERNS
                doji_patterns = self._detect_doji_patterns(candle, body_ratio, upper_shadow_ratio, lower_shadow_ratio, context)
                patterns.extend(doji_patterns)
                
                # HAMMER FAMILY PATTERNS  
                hammer_patterns = self._detect_hammer_patterns(candle, body_ratio, upper_shadow_ratio, lower_shadow_ratio, context)
                patterns.extend(hammer_patterns)
                  # SHOOTING STAR FAMILY
                shooting_star_patterns = self._detect_shooting_star_patterns(candle, body_ratio, upper_shadow_ratio, lower_shadow_ratio, context)
                patterns.extend(shooting_star_patterns)
                
                # MARUBOZU PATTERNS
                marubozu_patterns = self._detect_marubozu_patterns(candle, body_ratio, upper_shadow, lower_shadow, context)
                patterns.extend(marubozu_patterns)
                
                # SPINNING TOP PATTERNS
                spinning_top_patterns = self._detect_spinning_top_patterns(candle, body_ratio, upper_shadow_ratio, lower_shadow_ratio, context)
                patterns.extend(spinning_top_patterns)
                
                self.logger.debug(
                    "Single candle pattern analysis completed",
                    extra={"patterns_found": len(patterns)}
                )
                
                return patterns
                
            except Exception as e:
                self.logger.error(
                    "Error in single candle pattern analysis",
                    exc_info=e,
                    extra={
                        "candle_timestamp": candle.timestamp,
                        "error_type": type(e).__name__
                    }
                )
                return []
    
    def _detect_doji_patterns(self, candle: CandleData, body_ratio: float, 
                             upper_shadow_ratio: float, lower_shadow_ratio: float, 
                             context: Dict) -> List[PatternResult]:
        """Detect all Doji pattern variations"""
        patterns = []
        
        # Standard Doji: Small body, any shadow length
        if body_ratio <= 0.1:  # Body is ≤10% of total range
            
            # Long-Legged Doji: Long shadows on both sides
            if upper_shadow_ratio >= 2.0 and lower_shadow_ratio >= 2.0:
                strength = self._calculate_doji_strength(candle, context, 'long_legged')
                patterns.append(PatternResult(
                    pattern_name="Long-Legged Doji",
                    pattern_type="neutral",
                    strength_score=strength,
                    confidence=0.8,
                    confirmation_needed=True,
                    description="Strong indecision with long shadows on both sides"
                ))
            
            # Gravestone Doji: Long upper shadow, minimal lower shadow
            elif upper_shadow_ratio >= 3.0 and lower_shadow_ratio <= 0.5:
                strength = self._calculate_doji_strength(candle, context, 'gravestone')
                pattern_type = "bearish" if context.get('trend') == 'uptrend' else "neutral"
                patterns.append(PatternResult(
                    pattern_name="Gravestone Doji",
                    pattern_type=pattern_type,
                    strength_score=strength,
                    confidence=0.75,
                    confirmation_needed=True,
                    description="Bearish reversal signal in uptrend"
                ))
            
            # Dragonfly Doji: Long lower shadow, minimal upper shadow
            elif lower_shadow_ratio >= 3.0 and upper_shadow_ratio <= 0.5:
                strength = self._calculate_doji_strength(candle, context, 'dragonfly')
                pattern_type = "bullish" if context.get('trend') == 'downtrend' else "neutral"
                patterns.append(PatternResult(
                    pattern_name="Dragonfly Doji",
                    pattern_type=pattern_type,
                    strength_score=strength,
                    confidence=0.75,
                    confirmation_needed=True,
                    description="Bullish reversal signal in downtrend"
                ))
            
            # Standard Doji: Small body, moderate shadows
            else:
                strength = self._calculate_doji_strength(candle, context, 'standard')
                patterns.append(PatternResult(
                    pattern_name="Standard Doji",
                    pattern_type="neutral",
                    strength_score=strength,
                    confidence=0.6,
                    confirmation_needed=True,
                    description="Market indecision, trend reversal possible"
                ))
        
        return patterns
    
    def _detect_hammer_patterns(self, candle: CandleData, body_ratio: float,
                               upper_shadow_ratio: float, lower_shadow_ratio: float,
                               context: Dict) -> List[PatternResult]:
        """Detect Hammer and Hanging Man patterns"""
        patterns = []
        
        # Hammer/Hanging Man criteria: Small body, long lower shadow, small upper shadow
        if (0.1 <= body_ratio <= 0.4 and  # Medium-small body
            lower_shadow_ratio >= 2.0 and  # Long lower shadow
            upper_shadow_ratio <= 1.0):     # Small upper shadow
            
            trend = context.get('trend', 'neutral')
            
            if trend == 'downtrend':
                # Hammer in downtrend = Bullish reversal
                strength = self._calculate_hammer_strength(candle, context, 'hammer')
                patterns.append(PatternResult(
                    pattern_name="Hammer",
                    pattern_type="bullish",
                    strength_score=strength,
                    confidence=0.7,
                    confirmation_needed=True,
                    description="Bullish reversal signal in downtrend"
                ))
            
            elif trend == 'uptrend':
                # Hanging Man in uptrend = Bearish reversal
                strength = self._calculate_hammer_strength(candle, context, 'hanging_man')
                patterns.append(PatternResult(
                    pattern_name="Hanging Man",
                    pattern_type="bearish",
                    strength_score=strength,
                    confidence=0.65,
                    confirmation_needed=True,
                    description="Bearish reversal signal in uptrend"
                ))
        
        # Inverted Hammer criteria: Small body, long upper shadow, small lower shadow
        if (0.1 <= body_ratio <= 0.4 and  # Medium-small body
            upper_shadow_ratio >= 2.0 and  # Long upper shadow
            lower_shadow_ratio <= 1.0):     # Small lower shadow
            
            trend = context.get('trend', 'neutral')
            
            if trend == 'downtrend':
                # Inverted Hammer in downtrend = Potential bullish reversal
                strength = self._calculate_hammer_strength(candle, context, 'inverted_hammer')
                patterns.append(PatternResult(
                    pattern_name="Inverted Hammer",
                    pattern_type="bullish",
                    strength_score=strength,
                    confidence=0.6,
                    confirmation_needed=True,
                    description="Potential bullish reversal in downtrend"
                ))
            
            elif trend == 'uptrend':
                # Shooting Star in uptrend = Bearish reversal
                strength = self._calculate_hammer_strength(candle, context, 'shooting_star')
                patterns.append(PatternResult(
                    pattern_name="Shooting Star",
                    pattern_type="bearish",
                    strength_score=strength,
                    confidence=0.7,
                    confirmation_needed=True,
                    description="Bearish reversal signal in uptrend"
                ))
        
        return patterns
    
    def _detect_marubozu_patterns(self, candle: CandleData, body_ratio: float,
                                 upper_shadow: float, lower_shadow: float,
                                 context: Dict) -> List[PatternResult]:
        """Detect Marubozu patterns (strong momentum candles)"""
        patterns = []
        
        # Marubozu: Large body with minimal shadows
        if body_ratio >= 0.8 and upper_shadow <= 0.02 and lower_shadow <= 0.02:
            
            is_bullish = candle.close > candle.open
            pattern_type = "bullish" if is_bullish else "bearish"
            
            # Calculate strength based on volume and context
            strength = self._calculate_marubozu_strength(candle, context, is_bullish)
            
            pattern_name = "Bullish Marubozu" if is_bullish else "Bearish Marubozu"
            description = f"Strong {'bullish' if is_bullish else 'bearish'} momentum continuation"
            
            patterns.append(PatternResult(
                pattern_name=pattern_name,
                pattern_type=pattern_type,
                strength_score=strength,
                confidence=0.8,
                confirmation_needed=False,  # Strong momentum patterns need less confirmation
                description=description
            ))
        
        return patterns
    
    # ================================
    # TWO CANDLE PATTERNS (15 Patterns)
    # ================================
    
    def _analyze_two_candle_patterns(self, candles: List[CandleData], context: Dict) -> List[PatternResult]:
        """Analyze two-candle patterns"""
        if len(candles) < 2:
            return []
            
        patterns = []
        prev_candle, curr_candle = candles[-2], candles[-1]
        
        # ENGULFING PATTERNS
        patterns.extend(self._detect_engulfing_patterns(prev_candle, curr_candle, context))
        
        # HARAMI PATTERNS
        patterns.extend(self._detect_harami_patterns(prev_candle, curr_candle, context))
        
        # PIERCING LINE & DARK CLOUD COVER
        patterns.extend(self._detect_piercing_patterns(prev_candle, curr_candle, context))
        
        # TWEEZERS PATTERNS
        patterns.extend(self._detect_tweezers_patterns(prev_candle, curr_candle, context))
        
        # BELT HOLD PATTERNS
        patterns.extend(self._detect_belt_hold_patterns(prev_candle, curr_candle, context))
        
        return patterns
    
    def _detect_engulfing_patterns(self, prev_candle: CandleData, curr_candle: CandleData, 
                                  context: Dict) -> List[PatternResult]:
        """Detect Bullish and Bearish Engulfing patterns"""
        patterns = []
        
        prev_body_size = abs(prev_candle.close - prev_candle.open)
        curr_body_size = abs(curr_candle.close - curr_candle.open)
        
        # Bullish Engulfing: Previous bearish candle engulfed by current bullish candle
        if (prev_candle.close < prev_candle.open and  # Previous bearish
            curr_candle.close > curr_candle.open and  # Current bullish
            curr_candle.open < prev_candle.close and  # Opens below previous close
            curr_candle.close > prev_candle.open and  # Closes above previous open
            curr_body_size > prev_body_size):         # Current body larger
            
            strength = self._calculate_engulfing_strength(prev_candle, curr_candle, context, True)
            patterns.append(PatternResult(
                pattern_name="Bullish Engulfing",
                pattern_type="bullish",
                strength_score=strength,
                confidence=0.8,
                confirmation_needed=False,
                description="Strong bullish reversal pattern"
            ))
        
        # Bearish Engulfing: Previous bullish candle engulfed by current bearish candle
        elif (prev_candle.close > prev_candle.open and  # Previous bullish
              curr_candle.close < curr_candle.open and  # Current bearish
              curr_candle.open > prev_candle.close and  # Opens above previous close
              curr_candle.close < prev_candle.open and  # Closes below previous open
              curr_body_size > prev_body_size):         # Current body larger
            
            strength = self._calculate_engulfing_strength(prev_candle, curr_candle, context, False)
            patterns.append(PatternResult(
                pattern_name="Bearish Engulfing",
                pattern_type="bearish",
                strength_score=strength,
                confidence=0.8,
                confirmation_needed=False,
                description="Strong bearish reversal pattern"
            ))
        
        return patterns
    
    # ================================
    # PATTERN STRENGTH CALCULATION
    # ================================
    
    def _calculate_doji_strength(self, candle: CandleData, context: Dict, doji_type: str) -> float:
        """Calculate Doji pattern strength (0-100)"""
        base_strength = 50.0
        
        # Volume confirmation
        volume_avg = context.get('volume_average_20', candle.volume)
        if candle.volume > volume_avg * 1.5:
            base_strength += 20
        elif candle.volume < volume_avg * 0.5:
            base_strength -= 15
        
        # Support/Resistance level confirmation
        current_price = (candle.high + candle.low) / 2
        sr_levels = context.get('support_resistance_levels', [])
        
        for level in sr_levels:
            if abs(current_price - level) / current_price < 0.002:  # Within 20 pips
                base_strength += 15
                break
        
        # Trend context
        trend = context.get('trend', 'neutral')
        if doji_type in ['gravestone'] and trend == 'uptrend':
            base_strength += 10
        elif doji_type in ['dragonfly'] and trend == 'downtrend':
            base_strength += 10
        
        return min(100.0, max(0.0, base_strength))
    
    def _calculate_hammer_strength(self, candle: CandleData, context: Dict, hammer_type: str) -> float:
        """Calculate Hammer/Hanging Man pattern strength"""
        base_strength = 60.0
        
        # Volume confirmation
        volume_avg = context.get('volume_average_20', candle.volume)
        if candle.volume > volume_avg * 1.2:
            base_strength += 15
        
        # Trend context appropriateness
        trend = context.get('trend', 'neutral')
        if ((hammer_type == 'hammer' and trend == 'downtrend') or
            (hammer_type == 'hanging_man' and trend == 'uptrend')):
            base_strength += 20
        
        # Shadow length relative to recent range
        shadow_length = min(candle.open, candle.close) - candle.low
        recent_range = context.get('average_range_10', candle.high - candle.low)
        
        if shadow_length > recent_range * 0.5:
            base_strength += 10
        
        return min(100.0, max(0.0, base_strength))
    
    def _calculate_engulfing_strength(self, prev_candle: CandleData, curr_candle: CandleData,
                                     context: Dict, is_bullish: bool) -> float:
        """Calculate Engulfing pattern strength"""
        base_strength = 70.0
        
        # Size relationship
        prev_body = abs(prev_candle.close - prev_candle.open)
        curr_body = abs(curr_candle.close - curr_candle.open)
        
        size_ratio = curr_body / prev_body if prev_body > 0 else 1
        if size_ratio > 2.0:
            base_strength += 15
        elif size_ratio < 1.2:
            base_strength -= 10
        
        # Volume confirmation
        volume_avg = context.get('volume_average_20', curr_candle.volume)
        if curr_candle.volume > volume_avg * 1.3:
            base_strength += 20
        
        # Trend context
        trend = context.get('trend', 'neutral')
        if ((is_bullish and trend == 'downtrend') or
            (not is_bullish and trend == 'uptrend')):
            base_strength += 15
        
        return min(100.0, max(0.0, base_strength))
    
    def _rank_patterns_by_strength(self, patterns: List[PatternResult], context: Dict) -> List[PatternResult]:
        """Rank patterns by strength and filter weak patterns"""
        # Sort by strength score descending
        patterns.sort(key=lambda p: p.strength_score, reverse=True)
        
        # Filter out weak patterns (< 40 strength)
        strong_patterns = [p for p in patterns if p.strength_score >= 40]
        
        return strong_patterns[:10]  # Return top 10 patterns maximum
    
    def _initialize_pattern_database(self) -> Dict:
        """Initialize comprehensive pattern database"""
        return {
            'single_candle': [
                'Standard Doji', 'Long-Legged Doji', 'Gravestone Doji', 'Dragonfly Doji',
                'Hammer', 'Hanging Man', 'Inverted Hammer', 'Shooting Star',
                'Bullish Marubozu', 'Bearish Marubozu', 'Spinning Top'
            ],
            'two_candle': [
                'Bullish Engulfing', 'Bearish Engulfing', 'Bullish Harami', 'Bearish Harami',
                'Piercing Line', 'Dark Cloud Cover', 'Tweezers Top', 'Tweezers Bottom',
                'Belt Hold Bullish', 'Belt Hold Bearish'
            ],
            'three_candle': [
                'Morning Star', 'Evening Star', 'Three White Soldiers', 'Three Black Crows',
                'Three Inside Up', 'Three Inside Down', 'Three Outside Up', 'Three Outside Down'
            ],
            'complex_patterns': [
                'Abandoned Baby', 'Island Reversal', 'Ladder Top', 'Ladder Bottom',
                'Unique Three River Bottom', 'Three Stars in the South'
            ]
        }

# Export for use in other modules
__all__ = ['JapaneseCandlestickPatterns', 'CandleData', 'PatternResult']
