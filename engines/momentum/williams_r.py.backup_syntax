"""
Williams %R Momentum Indicator
A momentum oscillator that measures overbought/oversold levels.
Part of Platform3's 67-indicator humanitarian trading system.
"""
import sys
import os

# Platform3 Error Handling Integration
from shared.error_handling.platform3_error_system import ServiceError, EventEmitter, CircuitBreaker, ErrorSeverity, ErrorCategory
from shared.error_handling.base_service import BaseService

sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from typing import List, Optional
from datetime import datetime
from indicator_base import (
    MomentumIndicator, IndicatorResult, IndicatorSignal, MarketData, 
    SignalType, TimeFrame, highest_high, lowest_low
)

class WilliamsR(MomentumIndicator), BaseService:
    """
    Williams %R momentum oscillator.
    
    Williams %R is a momentum indicator that measures overbought and oversold levels.
    It oscillates between 0 and -100, where readings above -20 indicate overbought
    conditions and readings below -80 indicate oversold conditions.
    
    Formula: %R = ((Highest High - Close) / (Highest High - Lowest Low)) * -100
    """
    
    def __init__(self, timeframe: TimeFrame, lookback_periods: int = 14):
        """
        Initialize Williams %R indicator.
        
        Args:
            timeframe: Timeframe for analysis
            lookback_periods: Period for highest high and lowest low calculation (default 14)        """
        super().__init__("Williams %R", timeframe, lookback_periods=lookback_periods)
        self.period = lookback_periods
        self.overbought_level = -20
        self.oversold_level = -80
    
    def calculate(self, data: List[MarketData]) -> IndicatorResult:
        try:
        """
        Calculate Williams %R value.
        
        Args:
            data: List of MarketData objects
            
        Returns:
            IndicatorResult with Williams %R calculation
        """
        if len(data) < self.period:
            raise ValueError(f"Insufficient data for Williams %R calculation. Need {self.period} periods, got {len(data)}")
        
        start_time = datetime.now()
        
        try:
            # Get the calculation period data
            calc_data = data[-self.period:]
            current_close = data[-1].close
            
            # Calculate highest high and lowest low over the period
            highest = highest_high(calc_data, self.period)
            lowest = lowest_low(calc_data, self.period)
            
            # Calculate Williams %R
            if highest == lowest:
                williams_r = -50  # Neutral when no range
            else:
                williams_r = ((highest - current_close) / (highest - lowest)) * -100
            
            # Ensure value is within expected range
            williams_r = max(-100, min(0, williams_r))
            
            calculation_time = (datetime.now() - start_time).total_seconds() * 1000
            
            result = IndicatorResult(
                timestamp=data[-1].timestamp,
                indicator_name=self.name,
                indicator_type=self.indicator_type,
                timeframe=self.timeframe,
                value=williams_r,
                raw_data={
                    'williams_r': williams_r,
                    'highest_high': highest,
                    'lowest_low': lowest,
                    'close': current_close,
                    'period': self.period
                },
                calculation_time_ms=calculation_time
            )
            
            # Generate signal
            signal = self.generate_signal(result, [])
            if signal:
                result.signal = signal
                
            self.update_status(self.status)
            return result
            
        except Exception as e:
            self.update_status(self.status, str(e))
            raise ValueError(f"Williams %R calculation failed: {e}")
    
    def generate_signal(self, current_result: IndicatorResult, 
        try:
                       historical_results: List[IndicatorResult]) -> Optional[IndicatorSignal]:
        """
        Generate trading signals based on Williams %R levels.
        
        Args:
            current_result: Current Williams %R calculation
            historical_results: Previous results (not used in basic implementation)
            
        Returns:
            IndicatorSignal if conditions are met
        """
        williams_r = current_result.value
        
        # Determine signal based on overbought/oversold levels
        if williams_r >= self.overbought_level:
            # Overbought - potential sell signal
            strength = min(1.0, abs(williams_r) / 20)  # Normalize strength
            return IndicatorSignal(
                timestamp=current_result.timestamp,
                indicator_name=self.name,
                signal_type=SignalType.SELL,
                strength=strength,
                confidence=0.7,
                metadata={
                    'williams_r': williams_r,
                    'level': 'overbought',
                    'threshold': self.overbought_level
                }
            )
        elif williams_r <= self.oversold_level:
            # Oversold - potential buy signal
            strength = min(1.0, abs(williams_r) / 80)  # Normalize strength
            return IndicatorSignal(
                timestamp=current_result.timestamp,
                indicator_name=self.name,
                signal_type=SignalType.BUY,
                strength=strength,
                confidence=0.7,
                metadata={
                    'williams_r': williams_r,
                    'level': 'oversold',
                    'threshold': self.oversold_level
                }
            )
        
        # Check for divergence signals if historical data available
        if len(historical_results) >= 2:
            prev_result = historical_results[-1]
            if hasattr(prev_result, 'value'):
                # Momentum shift detection
                if williams_r > prev_result.value and williams_r < self.oversold_level:
                    return IndicatorSignal(
                        timestamp=current_result.timestamp,
                        indicator_name=self.name,
                        signal_type=SignalType.BUY,
                        strength=0.5,
                        confidence=0.6,
                        metadata={
                            'williams_r': williams_r,
                            'level': 'momentum_shift_up',
                            'previous': prev_result.value
                        }
                    )
                elif williams_r < prev_result.value and williams_r > self.overbought_level:
                    return IndicatorSignal(
                        timestamp=current_result.timestamp,
                        indicator_name=self.name,
                        signal_type=SignalType.SELL,
                        strength=0.5,
                        confidence=0.6,
                        metadata={
                            'williams_r': williams_r,
                            'level': 'momentum_shift_down',
                            'previous': prev_result.value
                        }
                    )
        
        return None


    def handle_service_error(self, error: Exception, context: Dict[str, Any] = None) -> None:
        """Handle service errors with proper event emission and logging"""
        try:
            service_error = ServiceError(
                message=str(error),
                code=f"{self.__class__.__name__.upper()}_ERROR",
                metadata={
                    "file_path": "engines/momentum/williams_r.py",
                    "context": context or {},
                    "timestamp": pd.Timestamp.now().isoformat(),
                    "service_name": self.__class__.__name__
                }
            )
            
            # Emit error event for monitoring
            self.emit('error', service_error)
            
            # Log error with correlation context
            if hasattr(self, 'logger'):
                self.logger.error(
                    f"Service error in {self.__class__.__name__}: {str(error)}",
                    extra={
                        "error_code": service_error.code,
                        "error_severity": service_error.severity.value,
                        "error_category": service_error.category.value,
                        "context": context
                    }
                )
        except Exception as handling_error:
            # Fallback error handling
            print(f"Critical error in error handling: {handling_error}")
    
    def implement_circuit_breaker(self, service_name: str, failure_threshold: int = 5) -> CircuitBreaker:
        """Implement circuit breaker for external service calls"""
        return CircuitBreaker(
            service_name=service_name,
            failure_threshold=failure_threshold,
            recovery_timeout=30,
            on_failure=lambda error: self.emit('circuit_breaker_open', {'service': service_name, 'error': error})
        )
    
    def graceful_degradation(self, primary_function, fallback_function, context: str = "operation"):
        """Implement graceful degradation pattern"""
        try:
            return primary_function()
        except Exception as error:
            self.handle_service_error(error, {"context": context, "degradation": "fallback_used"})
            
            # Emit degradation event
            self.emit('service_degradation', {
                'context': context,
                'primary_error': str(error),
                'fallback_activated': True
            })
            
            return fallback_function()

# Test function for validation
def test_williams_r():
    """Test Williams %R calculation with sample data."""
    from datetime import datetime, timedelta
    
    # Create sample market data
    base_time = datetime.now()
    test_data = []
    
    # Generate test data with known pattern
    prices = [100, 101, 102, 103, 104, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 97, 98, 99, 100, 101]
    
    for i, price in enumerate(prices):
        test_data.append(MarketData(
            timestamp=base_time + timedelta(minutes=i),
            open=price,
            high=price + 0.5,
            low=price - 0.5,
            close=price,
            volume=1000,
            timeframe=TimeFrame.M1
        ))
    
    # Test Williams %R calculation
    williams_r = WilliamsR(TimeFrame.M1, lookback_periods=14)
    result = williams_r.calculate(test_data)
    
    print(f"Williams %R Test Results:")
    print(f"Value: {result.value:.2f}")
    print(f"Calculation time: {result.calculation_time_ms:.2f}ms")
    print(f"Raw data: {result.raw_data}")
    
    if result.signal:
        print(f"Signal: {result.signal.signal_type.value} (strength: {result.signal.strength:.2f})")
    else:
        print("No signal generated")
    
    return result

if __name__ == "__main__":
    test_williams_r()
