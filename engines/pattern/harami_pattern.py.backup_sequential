# -*- coding: utf-8 -*-
"""
Harami Pattern Identifier - Japanese Candlestick Pattern Recognition
Platform3 Enhanced Technical Analysis Engine

Detects Bullish and Bearish Harami patterns, which are two-candle reversal patterns
where a small candle is contained within the body of the previous larger candle.
The word "harami" means "pregnant" in Japanese, as the pattern resembles a 
pregnant woman.

Pattern Characteristics:
- Two-candle pattern
- First candle has a large body
- Second candle's body is completely contained within the first candle's body
- Opposite colors (usually)
- Indicates potential trend reversal or consolidation

Key Features:
- Bullish and bearish harami detection
- Trend context analysis
- Volume confirmation
- Pattern strength measurement
- Reversal probability scoring
- Support/resistance level validation

Trading Applications:
- Trend reversal identification
- Consolidation phase detection
- Entry/exit timing optimization
- Risk management enhancement
- Market indecision analysis

Mathematical Foundation:
- Containment Condition: Body2 completely within Body1
- Size Ratio: Body2_Size / Body1_Size < threshold
- Trend Context: Direction of preceding trend
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Union
from dataclasses import dataclass
from enum import Enum
import logging

from ..indicator_base import IndicatorBase, IndicatorResult

class HaramiType(Enum):
    """Types of Harami patterns"""
    BULLISH_HARAMI = "bullish_harami"
    BEARISH_HARAMI = "bearish_harami"
    HARAMI_CROSS = "harami_cross"  # When second candle is a doji
    NO_PATTERN = "no_pattern"

class HaramiSignal(Enum):
    """Harami signal types"""
    STRONG_BULLISH_REVERSAL = "strong_bullish_reversal"
    STRONG_BEARISH_REVERSAL = "strong_bearish_reversal"
    BULLISH_REVERSAL = "bullish_reversal"
    BEARISH_REVERSAL = "bearish_reversal"
    INDECISION = "indecision"
    CONSOLIDATION = "consolidation"
    NEUTRAL = "neutral"

@dataclass
class HaramiCandlestick:
    """Individual candlestick data for Harami pattern"""
    open: float
    high: float
    low: float
    close: float
    volume: float
    body_size: float
    body_top: float
    body_bottom: float
    is_bullish: bool
    is_doji: bool
    
@dataclass
class HaramiPatternResult(IndicatorResult):
    """Harami Pattern identification result"""
    pattern_type: HaramiType
    pattern_strength: float  # 0-100, higher means stronger pattern
    containment_ratio: float  # How well the second candle is contained
    size_ratio: float  # Size of second candle relative to first
    mother_candle: HaramiCandlestick  # First (larger) candle
    baby_candle: HaramiCandlestick    # Second (smaller) candle
    trend_context: str  # 'uptrend', 'downtrend', 'sideways'
    reversal_probability: float  # 0-100
    indecision_level: float  # Market indecision measurement
    volume_confirmation: bool
    volume_ratio: float  # Current volume vs average
    support_resistance_level: Optional[float]
    signal: HaramiSignal
    signal_strength: float
    
    def to_dict(self) -> Dict:
        """Convert result to dictionary"""
        result_dict = super().to_dict()
        result_dict.update({
            'pattern_type': self.pattern_type.value,
            'pattern_strength': self.pattern_strength,
            'containment_ratio': self.containment_ratio,
            'size_ratio': self.size_ratio,
            'mother_candle': {
                'open': self.mother_candle.open,
                'high': self.mother_candle.high,
                'low': self.mother_candle.low,
                'close': self.mother_candle.close,
                'volume': self.mother_candle.volume,
                'body_size': self.mother_candle.body_size,
                'is_bullish': self.mother_candle.is_bullish,
                'is_doji': self.mother_candle.is_doji
            },
            'baby_candle': {
                'open': self.baby_candle.open,
                'high': self.baby_candle.high,
                'low': self.baby_candle.low,
                'close': self.baby_candle.close,
                'volume': self.baby_candle.volume,
                'body_size': self.baby_candle.body_size,
                'is_bullish': self.baby_candle.is_bullish,
                'is_doji': self.baby_candle.is_doji
            },
            'trend_context': self.trend_context,
            'reversal_probability': self.reversal_probability,
            'indecision_level': self.indecision_level,
            'volume_confirmation': self.volume_confirmation,
            'volume_ratio': self.volume_ratio,
            'support_resistance_level': self.support_resistance_level,
            'signal': self.signal.value,
            'signal_strength': self.signal_strength
        })
        return result_dict

class HaramiPatternIdentifier(IndicatorBase):
    """
    Harami Pattern Identifier - Japanese Candlestick Pattern Recognition
    
    Identifies Bullish and Bearish Harami patterns with comprehensive analysis
    including trend context, volume confirmation, and reversal probability.
    """
    
    def __init__(self, 
                 max_size_ratio: float = 0.8,
                 min_mother_body_ratio: float = 0.6,
                 doji_threshold: float = 0.1,
                 trend_period: int = 10,
                 volume_lookback: int = 10,
                 support_resistance_tolerance: float = 0.02):
        """
        Initialize Harami Pattern Identifier
        
        Args:
            max_size_ratio: Maximum ratio of baby to mother candle body (default: 0.8)
            min_mother_body_ratio: Minimum mother candle body size ratio (default: 0.6)
            doji_threshold: Threshold for identifying doji candles (default: 0.1)
            trend_period: Period for trend context analysis (default: 10)
            volume_lookback: Period for volume confirmation (default: 10)
            support_resistance_tolerance: Tolerance for S/R level detection (default: 2%)
        """
        super().__init__("Harami Pattern Identifier")
        self.max_size_ratio = max_size_ratio
        self.min_mother_body_ratio = min_mother_body_ratio
        self.doji_threshold = doji_threshold
        self.trend_period = trend_period
        self.volume_lookback = volume_lookback
        self.support_resistance_tolerance = support_resistance_tolerance
        
        # Validation
        if not 0 < self.max_size_ratio < 1:
            raise ValueError("Max size ratio must be between 0 and 1")
        if not 0 < self.min_mother_body_ratio < 1:
            raise ValueError("Min mother body ratio must be between 0 and 1")
        if not 0 < self.doji_threshold < 0.5:
            raise ValueError("Doji threshold must be between 0 and 0.5")
        if self.trend_period < 3:
            raise ValueError("Trend period must be >= 3")
        if self.volume_lookback < 2:
            raise ValueError("Volume lookback must be >= 2")
            
        # State variables
        self.reset()
        
    def reset(self) -> None:
        """Reset indicator state"""
        super().reset()
        self.candles = []
        self.patterns = []
        
    def _create_harami_candlestick(self, open_price: float, high: float, low: float, 
                                  close: float, volume: float) -> HaramiCandlestick:
        """Create Harami candlestick data object"""
        body_size = abs(close - open_price)
        body_top = max(open_price, close)
        body_bottom = min(open_price, close)
        is_bullish = close > open_price
        
        # Check if it's a doji
        total_range = high - low
        is_doji = (body_size / total_range) < self.doji_threshold if total_range > 0 else False
        
        return HaramiCandlestick(
            open=open_price,
            high=high,
            low=low,
            close=close,
            volume=volume,
            body_size=body_size,
            body_top=body_top,
            body_bottom=body_bottom,
            is_bullish=is_bullish,
            is_doji=is_doji
        )
    
    def _is_valid_harami_pattern(self, mother_candle: HaramiCandlestick, 
                                baby_candle: HaramiCandlestick) -> Tuple[bool, HaramiType]:
        """Check if two candles form a valid Harami pattern"""
        # Check mother candle requirements
        mother_range = mother_candle.high - mother_candle.low
        if mother_range == 0:
            return False, HaramiType.NO_PATTERN
            
        mother_body_ratio = mother_candle.body_size / mother_range
        if mother_body_ratio < self.min_mother_body_ratio:
            return False, HaramiType.NO_PATTERN
            
        # Check size ratio requirement
        if mother_candle.body_size == 0:
            return False, HaramiType.NO_PATTERN
            
        size_ratio = baby_candle.body_size / mother_candle.body_size
        if size_ratio > self.max_size_ratio:
            return False, HaramiType.NO_PATTERN
            
        # Check containment - baby body must be within mother body
        baby_contained = (baby_candle.body_top <= mother_candle.body_top and 
                         baby_candle.body_bottom >= mother_candle.body_bottom)
        
        if not baby_contained:
            return False, HaramiType.NO_PATTERN
            
        # Determine pattern type
        if baby_candle.is_doji:
            return True, HaramiType.HARAMI_CROSS
        elif mother_candle.is_bullish and not baby_candle.is_bullish:
            return True, HaramiType.BEARISH_HARAMI
        elif not mother_candle.is_bullish and baby_candle.is_bullish:
            return True, HaramiType.BULLISH_HARAMI
        else:
            # Same color harami (less common but valid)
            if mother_candle.is_bullish:
                return True, HaramiType.BEARISH_HARAMI  # Bearish signal in uptrend
            else:
                return True, HaramiType.BULLISH_HARAMI  # Bullish signal in downtrend
    
    def _calculate_containment_ratio(self, mother_candle: HaramiCandlestick, 
                                    baby_candle: HaramiCandlestick) -> float:
        """Calculate how well the baby candle is contained within the mother"""
        if mother_candle.body_size == 0:
            return 0.0
            
        # Calculate available space for baby candle
        available_space = mother_candle.body_size
        
        # Calculate how much space baby candle uses
        used_space = baby_candle.body_size
        
        # Calculate centering bonus
        mother_center = (mother_candle.body_top + mother_candle.body_bottom) / 2
        baby_center = (baby_candle.body_top + baby_candle.body_bottom) / 2
        
        center_distance = abs(mother_center - baby_center)
        max_distance = mother_candle.body_size / 2
        
        centering_ratio = 1 - (center_distance / max_distance) if max_distance > 0 else 1
        
        # Size efficiency (smaller baby is better contained)
        size_efficiency = 1 - (used_space / available_space)
        
        # Overall containment ratio
        containment_ratio = (centering_ratio * 0.4 + size_efficiency * 0.6) * 100
        return min(100, max(0, containment_ratio))
    
    def _calculate_pattern_strength(self, pattern_type: HaramiType, 
                                   mother_candle: HaramiCandlestick,
                                   baby_candle: HaramiCandlestick,
                                   containment_ratio: float,
                                   size_ratio: float) -> float:
        """Calculate the strength of the Harami pattern (0-100)"""
        if pattern_type == HaramiType.NO_PATTERN:
            return 0.0
            
        # Base strength from containment quality
        containment_strength = containment_ratio * 0.4
        
        # Strength from size ratio (smaller baby is stronger)
        size_strength = (1 - size_ratio) * 30
        
        # Mother candle quality (larger body is better)
        mother_range = mother_candle.high - mother_candle.low
        if mother_range > 0:
            mother_body_ratio = mother_candle.body_size / mother_range
            mother_strength = mother_body_ratio * 20
        else:
            mother_strength = 0
            
        # Pattern type bonus
        type_bonus = {
            HaramiType.HARAMI_CROSS: 10,  # Doji harami is stronger
            HaramiType.BULLISH_HARAMI: 5,
            HaramiType.BEARISH_HARAMI: 5
        }.get(pattern_type, 0)
        
        final_strength = containment_strength + size_strength + mother_strength + type_bonus
        return min(100, max(0, final_strength))
    
    def _calculate_indecision_level(self, pattern_type: HaramiType, baby_candle: HaramiCandlestick,
                                   size_ratio: float) -> float:
        """Calculate market indecision level (0-100)"""
        # Base indecision from pattern type
        base_indecision = {
            HaramiType.HARAMI_CROSS: 85,  # Doji shows high indecision
            HaramiType.BULLISH_HARAMI: 60,
            HaramiType.BEARISH_HARAMI: 60,
            HaramiType.NO_PATTERN: 0
        }.get(pattern_type, 0)
        
        # Adjust for baby candle size (smaller = more indecision)
        size_adjustment = (1 - size_ratio) * 20
        
        # Adjust for baby candle shadows
        baby_range = baby_candle.high - baby_candle.low
        if baby_range > 0 and baby_candle.body_size > 0:
            upper_shadow = baby_candle.high - baby_candle.body_top
            lower_shadow = baby_candle.body_bottom - baby_candle.low
            total_shadows = upper_shadow + lower_shadow
            shadow_ratio = total_shadows / baby_range
            
            # More shadows = more indecision
            shadow_adjustment = shadow_ratio * 15
        else:
            shadow_adjustment = 0
            
        indecision_level = base_indecision + size_adjustment + shadow_adjustment
        return min(100, max(0, indecision_level))
    
    def _determine_trend_context(self) -> str:
        """Determine current trend context"""
        if len(self.candles) < self.trend_period:
            return 'sideways'
            
        # Use closing prices for trend analysis
        recent_closes = [candle.close for candle in self.candles[-self.trend_period:]]
        
        # Calculate trend slope using linear regression
        x = np.arange(len(recent_closes))
        slope = np.polyfit(x, recent_closes, 1)[0]
        
        # Normalize slope by price range
        price_range = max(recent_closes) - min(recent_closes)
        relative_slope = slope / price_range if price_range > 0 else 0
        
        # Classify trend
        if relative_slope > 0.1:
            return 'uptrend'
        elif relative_slope < -0.1:
            return 'downtrend'
        else:
            return 'sideways'
    
    def _find_support_resistance_level(self, mother_candle: HaramiCandlestick, 
                                      baby_candle: HaramiCandlestick) -> Optional[float]:
        """Find nearby support/resistance levels"""
        if len(self.candles) < 5:
            return None
            
        # Get recent highs and lows
        recent_highs = [candle.high for candle in self.candles[-20:]] if len(self.candles) >= 20 else [candle.high for candle in self.candles]
        recent_lows = [candle.low for candle in self.candles[-20:]] if len(self.candles) >= 20 else [candle.low for candle in self.candles]
        
        all_levels = recent_highs + recent_lows
        
        # Pattern price levels
        pattern_high = max(mother_candle.high, baby_candle.high)
        pattern_low = min(mother_candle.low, baby_candle.low)
        pattern_center = (pattern_high + pattern_low) / 2
        
        # Find levels near pattern
        tolerance = (pattern_high - pattern_low) * self.support_resistance_tolerance
        
        for level in all_levels:
            if (abs(level - pattern_low) <= tolerance or 
                abs(level - pattern_high) <= tolerance or
                abs(level - pattern_center) <= tolerance):
                return level
                
        return None
    
    def _calculate_volume_ratio(self, current_volume: float) -> float:
        """Calculate current volume ratio vs average"""
        if len(self.candles) < self.volume_lookback:
            return 1.0
            
        recent_volumes = [candle.volume for candle in self.candles[-self.volume_lookback:]]
        avg_volume = sum(recent_volumes) / len(recent_volumes)
        
        return current_volume / avg_volume if avg_volume > 0 else 1.0
    
    def _calculate_reversal_probability(self, pattern_type: HaramiType, pattern_strength: float,
                                       trend_context: str, indecision_level: float,
                                       volume_confirmation: bool,
                                       support_resistance_level: Optional[float]) -> float:
        """Calculate probability of trend reversal (0-100)"""
        base_probability = {
            HaramiType.HARAMI_CROSS: 70,  # Doji harami has high reversal potential
            HaramiType.BULLISH_HARAMI: 60,
            HaramiType.BEARISH_HARAMI: 60,
            HaramiType.NO_PATTERN: 0
        }.get(pattern_type, 0)
        
        # Adjust for trend context appropriateness
        if pattern_type == HaramiType.BULLISH_HARAMI and trend_context == 'downtrend':
            trend_adjustment = 1.3
        elif pattern_type == HaramiType.BEARISH_HARAMI and trend_context == 'uptrend':
            trend_adjustment = 1.3
        elif pattern_type == HaramiType.HARAMI_CROSS:
            trend_adjustment = 1.1  # Doji harami works in any trend
        elif trend_context == 'sideways':
            trend_adjustment = 0.7  # Less reversal potential in sideways market
        else:
            trend_adjustment = 0.6  # Counter-trend pattern
            
        # Adjust for pattern strength
        strength_adjustment = pattern_strength / 100
        
        # Adjust for indecision level (higher indecision = more reversal potential)
        indecision_adjustment = 1 + (indecision_level / 200)  # Up to 50% bonus
        
        # Adjust for volume confirmation
        volume_adjustment = 1.1 if volume_confirmation else 0.9
        
        # Adjust for support/resistance level
        sr_adjustment = 1.15 if support_resistance_level is not None else 1.0
        
        probability = (base_probability * trend_adjustment * strength_adjustment * 
                      indecision_adjustment * volume_adjustment * sr_adjustment)
        return min(100, max(0, probability))
    
    def _generate_signal(self, pattern_type: HaramiType, reversal_probability: float,
                        indecision_level: float, trend_context: str,
                        volume_confirmation: bool) -> Tuple[HaramiSignal, float]:
        """Generate trading signal based on pattern analysis"""
        if pattern_type == HaramiType.NO_PATTERN:
            return HaramiSignal.NEUTRAL, 25
            
        # High indecision signals
        if indecision_level > 70:
            if reversal_probability > 70:
                if pattern_type == HaramiType.BULLISH_HARAMI:
                    return HaramiSignal.STRONG_BULLISH_REVERSAL, reversal_probability
                elif pattern_type == HaramiType.BEARISH_HARAMI:
                    return HaramiSignal.STRONG_BEARISH_REVERSAL, reversal_probability
                else:  # HARAMI_CROSS
                    return HaramiSignal.INDECISION, indecision_level
            else:
                return HaramiSignal.INDECISION, indecision_level
                
        # Strong reversal signals
        elif reversal_probability > 75 and volume_confirmation:
            if pattern_type == HaramiType.BULLISH_HARAMI:
                return HaramiSignal.STRONG_BULLISH_REVERSAL, reversal_probability
            else:
                return HaramiSignal.STRONG_BEARISH_REVERSAL, reversal_probability
                
        # Medium reversal signals
        elif reversal_probability > 55:
            if pattern_type == HaramiType.BULLISH_HARAMI:
                return HaramiSignal.BULLISH_REVERSAL, reversal_probability
            elif pattern_type == HaramiType.BEARISH_HARAMI:
                return HaramiSignal.BEARISH_REVERSAL, reversal_probability
            else:  # HARAMI_CROSS
                return HaramiSignal.INDECISION, indecision_level
                
        # Consolidation signals
        elif reversal_probability > 30:
            return HaramiSignal.CONSOLIDATION, reversal_probability
            
        return HaramiSignal.NEUTRAL, 25
    
    def update(self, open_price: float, high: float, low: float, close: float, 
               volume: float = 0, timestamp: Optional[pd.Timestamp] = None) -> HaramiPatternResult:
        """
        Update Harami Pattern Identifier with new candlestick data
        
        Args:
            open_price: Opening price
            high: High price
            low: Low price
            close: Close price
            volume: Volume (optional)
            timestamp: Optional timestamp
            
        Returns:
            HaramiPatternResult: Pattern identification result
        """
        try:
            # Create current candlestick
            current_candle = self._create_harami_candlestick(open_price, high, low, close, volume)
            self.candles.append(current_candle)
            
            # Initialize default result
            pattern_type = HaramiType.NO_PATTERN
            pattern_strength = 0.0
            containment_ratio = 0.0
            size_ratio = 0.0
            mother_candle = current_candle
            baby_candle = current_candle
            
            # Check for Harami pattern (need at least 2 candles)
            if len(self.candles) >= 2:
                potential_mother = self.candles[-2]
                potential_baby = self.candles[-1]
                
                is_harami, pattern_type = self._is_valid_harami_pattern(potential_mother, potential_baby)
                
                if is_harami:
                    mother_candle = potential_mother
                    baby_candle = potential_baby
                    containment_ratio = self._calculate_containment_ratio(mother_candle, baby_candle)
                    size_ratio = baby_candle.body_size / mother_candle.body_size
                    pattern_strength = self._calculate_pattern_strength(
                        pattern_type, mother_candle, baby_candle, containment_ratio, size_ratio
                    )
            
            # Calculate indecision level
            indecision_level = self._calculate_indecision_level(pattern_type, baby_candle, size_ratio)
            
            # Determine trend context
            trend_context = self._determine_trend_context()
            
            # Find support/resistance level
            support_resistance_level = self._find_support_resistance_level(mother_candle, baby_candle)
            
            # Calculate volume metrics
            volume_ratio = self._calculate_volume_ratio(volume)
            volume_confirmation = volume_ratio > 1.1
            
            # Calculate reversal probability
            reversal_probability = self._calculate_reversal_probability(
                pattern_type, pattern_strength, trend_context, indecision_level,
                volume_confirmation, support_resistance_level
            )
            
            # Generate signal
            signal, signal_strength = self._generate_signal(
                pattern_type, reversal_probability, indecision_level, trend_context, volume_confirmation
            )
            
            # Create result
            result = HaramiPatternResult(
                timestamp=timestamp or pd.Timestamp.now(),
                value=pattern_strength,
                pattern_type=pattern_type,
                pattern_strength=pattern_strength,
                containment_ratio=containment_ratio,
                size_ratio=size_ratio,
                mother_candle=mother_candle,
                baby_candle=baby_candle,
                trend_context=trend_context,
                reversal_probability=reversal_probability,
                indecision_level=indecision_level,
                volume_confirmation=volume_confirmation,
                volume_ratio=volume_ratio,
                support_resistance_level=support_resistance_level,
                signal=signal,
                signal_strength=signal_strength,
                metadata={
                    'max_size_ratio': self.max_size_ratio,
                    'min_mother_body_ratio': self.min_mother_body_ratio,
                    'doji_threshold': self.doji_threshold,
                    'trend_period': self.trend_period,
                    'volume_lookback': self.volume_lookback
                }
            )
            
            self.patterns.append(result)
            self.last_result = result
            return result
            
        except Exception as e:
            self.logger.error(f"Error updating Harami Pattern Identifier: {str(e)}")
            raise
    
    def get_recent_patterns(self, lookback: int = 10) -> List[HaramiPatternResult]:
        """Get recent patterns"""
        return self.patterns[-lookback:] if len(self.patterns) >= lookback else self.patterns
    
    def __str__(self) -> str:
        return f"HaramiPatternIdentifier(max_size_ratio={self.max_size_ratio}, trend_period={self.trend_period})"
