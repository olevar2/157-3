"""
Adaptive Indicators - Self-Adjusting Parameter Indicators

This module implements AI-powered adaptive indicators that automatically adjust
their parameters based on market conditions, volatility, and regime changes.
Uses machine learning to optimize indicator parameters in real-time.

Mathematical Foundation:
- Kalman Filter for parameter adaptation
- Genetic Algorithm optimization
- Volatility-based parameter scaling
- Regime-dependent parameter sets
- Performance feedback loops
- Online learning algorithms

Author: Platform3 Trading System
Version: 1.0.0 - AI Enhancement
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import warnings
from scipy import optimize
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from ..indicator_base import IndicatorBase

warnings.filterwarnings('ignore')

@dataclass
class AdaptiveSignal:
    """Signal generated by adaptive indicators."""
    timestamp: datetime
    indicator_value: float
    optimal_parameters: Dict[str, float]
    adaptation_score: float
    regime_type: str
    volatility_factor: float
    parameter_stability: float
    performance_score: float
    confidence: float

@dataclass
class ParameterSet:
    """Set of optimized parameters for different market conditions."""
    regime: str
    parameters: Dict[str, float]
    performance: float
    stability_score: float
    usage_count: int
    last_updated: datetime

class AdaptiveIndicators(IndicatorBase):
    """
    Adaptive Indicators with AI-Powered Parameter Optimization
    
    Automatically adjusts indicator parameters based on market conditions,
    volatility, and performance feedback using machine learning algorithms.
    """
    
    def __init__(self, 
                 base_indicator: str = 'RSI',
                 adaptation_period: int = 50,
                 optimization_window: int = 200,
                 performance_memory: int = 100,
                 volatility_sensitivity: float = 0.5,
                 adaptation_rate: float = 0.1):
        """
        Initialize Adaptive Indicators.
        
        Args:
            base_indicator: Base indicator to adapt ('RSI', 'MACD', 'EMA', etc.)
            adaptation_period: Period for parameter updates
            optimization_window: Window for performance evaluation
            performance_memory: Memory length for performance tracking
            volatility_sensitivity: Sensitivity to volatility changes
            adaptation_rate: Rate of parameter adaptation
        """
        super().__init__(adaptation_period)
        self.base_indicator = base_indicator
        self.optimization_window = optimization_window
        self.performance_memory = performance_memory
        self.volatility_sensitivity = volatility_sensitivity
        self.adaptation_rate = adaptation_rate
        
        # Parameter management
        self.parameter_sets: Dict[str, ParameterSet] = {}
        self.current_parameters = self._get_default_parameters()
        self.parameter_history = []
        
        # Performance tracking
        self.performance_scores = []
        self.adaptation_scores = []
        
        # ML components
        self.scaler = StandardScaler()
        self.regime_classifier = None
        self.parameter_optimizer = None
        
        # Market state tracking
        self.volatility_states = []
        self.trend_states = []
        self.regime_states = []
        
    def _get_default_parameters(self) -> Dict[str, float]:
        """Get default parameters for the base indicator."""
        defaults = {
            'RSI': {'period': 14, 'overbought': 70, 'oversold': 30},
            'MACD': {'fast': 12, 'slow': 26, 'signal': 9},
            'EMA': {'period': 20, 'multiplier': 2},
            'Bollinger': {'period': 20, 'std_dev': 2},
            'Stochastic': {'k_period': 14, 'd_period': 3, 'overbought': 80, 'oversold': 20}
        }
        return defaults.get(self.base_indicator, {'period': 14})
    
    def _calculate_market_regime(self, data: np.ndarray) -> str:
        """Identify current market regime."""
        if len(data) < 20:
            return 'unknown'
        
        # Calculate volatility
        returns = np.diff(data) / data[:-1]
        volatility = np.std(returns[-20:])
        
        # Calculate trend strength
        trend_slope = np.polyfit(range(20), data[-20:], 1)[0]
        trend_strength = abs(trend_slope) / np.mean(data[-20:])
        
        # Classify regime
        high_vol_threshold = np.percentile(self.volatility_states[-100:] if len(self.volatility_states) > 100 else [volatility], 75)
        high_trend_threshold = 0.001  # 0.1% per period
        
        if volatility > high_vol_threshold:
            return 'high_volatility'
        elif trend_strength > high_trend_threshold:
            return 'trending' if trend_slope > 0 else 'declining'
        else:
            return 'ranging'
    
    def _calculate_volatility_factor(self, data: np.ndarray) -> float:
        """Calculate volatility factor for parameter scaling."""
        if len(data) < 10:
            return 1.0
        
        returns = np.diff(data) / data[:-1]
        current_vol = np.std(returns[-10:])
        
        if len(self.volatility_states) > 0:
            baseline_vol = np.mean(self.volatility_states[-50:])
            volatility_ratio = current_vol / (baseline_vol + 1e-8)
        else:
            volatility_ratio = 1.0
        
        # Scale factor based on volatility ratio
        return 1.0 + (volatility_ratio - 1.0) * self.volatility_sensitivity
    
    def _optimize_parameters(self, data: np.ndarray, regime: str) -> Dict[str, float]:
        """Optimize parameters using genetic algorithm approach."""
        if len(data) < self.optimization_window:
            return self.current_parameters
        
        optimization_data = data[-self.optimization_window:]
        
        def objective_function(params):
            """Objective function for parameter optimization."""
            try:
                # Calculate indicator with given parameters
                indicator_values = self._calculate_base_indicator(optimization_data, params)
                
                # Calculate performance score
                performance = self._calculate_performance_score(
                    optimization_data, indicator_values
                )
                
                return -performance  # Minimize negative performance
            except:
                return 1000  # Penalty for invalid parameters
        
        # Define parameter bounds based on base indicator
        bounds = self._get_parameter_bounds()
        
        # Use differential evolution for global optimization
        try:
            result = optimize.differential_evolution(
                objective_function,
                bounds,
                maxiter=50,
                popsize=10,
                seed=42
            )
            
            if result.success:
                optimized_params = self._params_array_to_dict(result.x)
                return optimized_params
        except:
            pass
        
        return self.current_parameters
    
    def _get_parameter_bounds(self) -> List[Tuple[float, float]]:
        """Get parameter bounds for optimization."""
        if self.base_indicator == 'RSI':
            return [(5, 50), (60, 90), (10, 40)]  # period, overbought, oversold
        elif self.base_indicator == 'MACD':
            return [(5, 25), (15, 50), (3, 20)]  # fast, slow, signal
        elif self.base_indicator == 'EMA':
            return [(5, 100), (1, 5)]  # period, multiplier
        elif self.base_indicator == 'Bollinger':
            return [(10, 50), (1, 4)]  # period, std_dev
        else:
            return [(5, 50)]  # generic period
    
    def _params_array_to_dict(self, params_array: np.ndarray) -> Dict[str, float]:
        """Convert parameter array to dictionary."""
        if self.base_indicator == 'RSI':
            return {
                'period': int(params_array[0]),
                'overbought': params_array[1],
                'oversold': params_array[2]
            }
        elif self.base_indicator == 'MACD':
            return {
                'fast': int(params_array[0]),
                'slow': int(params_array[1]),
                'signal': int(params_array[2])
            }
        elif self.base_indicator == 'EMA':
            return {
                'period': int(params_array[0]),
                'multiplier': params_array[1]
            }
        elif self.base_indicator == 'Bollinger':
            return {
                'period': int(params_array[0]),
                'std_dev': params_array[1]
            }
        else:
            return {'period': int(params_array[0])}
    
    def _calculate_base_indicator(self, data: np.ndarray, params: Dict[str, float]) -> np.ndarray:
        """Calculate base indicator with given parameters."""
        if self.base_indicator == 'RSI':
            return self._calculate_rsi(data, int(params['period']))
        elif self.base_indicator == 'MACD':
            return self._calculate_macd(data, int(params['fast']), 
                                      int(params['slow']), int(params['signal']))
        elif self.base_indicator == 'EMA':
            return self._calculate_ema(data, int(params['period']))
        elif self.base_indicator == 'Bollinger':
            bb_upper, bb_middle, bb_lower = self._calculate_bollinger_bands(
                data, int(params['period']), params['std_dev']
            )
            return bb_middle  # Return middle band as representative value
        else:
            # Default to simple moving average
            return self._calculate_sma(data, int(params.get('period', 14)))
    
    def _calculate_rsi(self, data: np.ndarray, period: int) -> np.ndarray:
        """Calculate RSI with given period."""
        if len(data) < period + 1:
            return np.full(len(data), 50.0)
        
        deltas = np.diff(data)
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)
        
        avg_gains = np.convolve(gains, np.ones(period)/period, mode='valid')
        avg_losses = np.convolve(losses, np.ones(period)/period, mode='valid')
        
        rs = avg_gains / (avg_losses + 1e-8)
        rsi = 100 - (100 / (1 + rs))
        
        # Pad to match input length
        return np.concatenate([np.full(len(data) - len(rsi), 50.0), rsi])
    
    def _calculate_macd(self, data: np.ndarray, fast: int, slow: int, signal: int) -> np.ndarray:
        """Calculate MACD line."""
        if len(data) < slow:
            return np.zeros(len(data))
        
        ema_fast = self._calculate_ema(data, fast)
        ema_slow = self._calculate_ema(data, slow)
        macd_line = ema_fast - ema_slow
        
        return macd_line
    
    def _calculate_ema(self, data: np.ndarray, period: int) -> np.ndarray:
        """Calculate EMA."""
        if len(data) == 0:
            return np.array([])
        
        alpha = 2 / (period + 1)
        ema = np.zeros_like(data, dtype=float)
        ema[0] = data[0]
        
        for i in range(1, len(data)):
            ema[i] = alpha * data[i] + (1 - alpha) * ema[i-1]
        
        return ema
    
    def _calculate_sma(self, data: np.ndarray, period: int) -> np.ndarray:
        """Calculate Simple Moving Average."""
        if len(data) < period:
            return np.full(len(data), np.mean(data))
        
        sma = np.convolve(data, np.ones(period)/period, mode='valid')
        return np.concatenate([np.full(period-1, np.mean(data[:period])), sma])
    
    def _calculate_bollinger_bands(self, data: np.ndarray, period: int, std_dev: float) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Calculate Bollinger Bands."""
        sma = self._calculate_sma(data, period)
        
        if len(data) < period:
            std = np.std(data)
            return sma + std_dev * std, sma, sma - std_dev * std
        
        rolling_std = np.array([
            np.std(data[max(0, i-period+1):i+1]) 
            for i in range(len(data))
        ])
        
        upper = sma + std_dev * rolling_std
        lower = sma - std_dev * rolling_std
        
        return upper, sma, lower
    
    def _calculate_performance_score(self, price_data: np.ndarray, 
                                   indicator_values: np.ndarray) -> float:
        """Calculate performance score for parameter optimization."""
        if len(price_data) != len(indicator_values) or len(price_data) < 10:
            return 0.0
        
        # Calculate returns
        returns = np.diff(price_data) / price_data[:-1]
        
        # Generate signals based on indicator
        signals = self._generate_signals_from_indicator(indicator_values)
        
        if len(signals) != len(returns):
            signals = signals[:len(returns)]
        
        # Calculate strategy returns
        strategy_returns = returns * signals
        
        # Performance metrics
        total_return = np.sum(strategy_returns)
        volatility = np.std(strategy_returns)
        sharpe_ratio = total_return / (volatility + 1e-8) * np.sqrt(252)  # Annualized
        
        # Win rate
        winning_trades = np.sum(strategy_returns > 0)
        total_trades = np.sum(np.abs(signals) > 0)
        win_rate = winning_trades / (total_trades + 1e-8)
        
        # Combined performance score
        performance = (
            sharpe_ratio * 0.4 +
            total_return * 1000 * 0.3 +  # Scale return
            win_rate * 0.3
        )
        
        return performance
    
    def _generate_signals_from_indicator(self, indicator_values: np.ndarray) -> np.ndarray:
        """Generate trading signals from indicator values."""
        signals = np.zeros(len(indicator_values))
        
        if self.base_indicator == 'RSI':
            # RSI-based signals
            overbought = self.current_parameters.get('overbought', 70)
            oversold = self.current_parameters.get('oversold', 30)
            
            signals[indicator_values > overbought] = -1  # Sell
            signals[indicator_values < oversold] = 1     # Buy
            
        elif self.base_indicator == 'MACD':
            # MACD crossover signals
            for i in range(1, len(indicator_values)):
                if indicator_values[i] > 0 and indicator_values[i-1] <= 0:
                    signals[i] = 1  # Buy
                elif indicator_values[i] < 0 and indicator_values[i-1] >= 0:
                    signals[i] = -1  # Sell
        
        else:
            # Generic momentum signals
            for i in range(1, len(indicator_values)):
                if indicator_values[i] > indicator_values[i-1]:
                    signals[i] = 1
                elif indicator_values[i] < indicator_values[i-1]:
                    signals[i] = -1
        
        return signals
    
    def _update_parameter_sets(self, regime: str, params: Dict[str, float], 
                             performance: float):
        """Update parameter sets for different regimes."""
        if regime in self.parameter_sets:
            param_set = self.parameter_sets[regime]
            
            # Update with exponential moving average
            alpha = 0.1
            param_set.performance = (alpha * performance + 
                                   (1 - alpha) * param_set.performance)
            param_set.usage_count += 1
            param_set.last_updated = datetime.now()
        else:
            # Create new parameter set
            self.parameter_sets[regime] = ParameterSet(
                regime=regime,
                parameters=params.copy(),
                performance=performance,
                stability_score=1.0,
                usage_count=1,
                last_updated=datetime.now()
            )
    
    def _calculate_parameter_stability(self, params: Dict[str, float]) -> float:
        """Calculate stability score of parameters."""
        if len(self.parameter_history) < 5:
            return 1.0
        
        recent_params = self.parameter_history[-5:]
        
        # Calculate variance of parameters
        stability_scores = []
        for key in params.keys():
            values = [p.get(key, 0) for p in recent_params]
            if len(values) > 1:
                stability = 1.0 / (1.0 + np.var(values))
                stability_scores.append(stability)
        
        return np.mean(stability_scores) if stability_scores else 1.0
    
    def calculate(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate adaptive indicators.
        
        Args:
            data: DataFrame with OHLCV data
            
        Returns:
            DataFrame with adaptive indicator signals
        """
        if len(data) < self.period:
            return pd.DataFrame()
        
        results = []
        prices = data['close'].values
        
        for i in range(self.period, len(data)):
            window_data = prices[:i+1]
            
            # Identify market regime
            regime = self._calculate_market_regime(window_data)
            
            # Calculate volatility factor
            volatility_factor = self._calculate_volatility_factor(window_data)
            
            # Store market states
            self.volatility_states.append(np.std(np.diff(window_data[-20:]) / window_data[-21:-1]))
            self.regime_states.append(regime)
            
            # Optimize parameters if needed
            if i % self.adaptation_period == 0 or regime not in self.parameter_sets:
                optimized_params = self._optimize_parameters(window_data, regime)
                
                # Apply volatility scaling
                scaled_params = self._apply_volatility_scaling(optimized_params, volatility_factor)
                
                # Update parameters with adaptation rate
                self.current_parameters = self._blend_parameters(
                    self.current_parameters, scaled_params, self.adaptation_rate
                )
                
                # Calculate performance for current parameters
                indicator_values = self._calculate_base_indicator(
                    window_data[-self.optimization_window:], self.current_parameters
                )
                performance = self._calculate_performance_score(
                    window_data[-self.optimization_window:], indicator_values
                )
                
                # Update parameter sets
                self._update_parameter_sets(regime, self.current_parameters, performance)
                
                # Store parameter history
                self.parameter_history.append(self.current_parameters.copy())
                if len(self.parameter_history) > self.performance_memory:
                    self.parameter_history.pop(0)
            
            # Calculate indicator value with current parameters
            indicator_value = self._calculate_base_indicator(
                window_data, self.current_parameters
            )[-1]
            
            # Calculate metrics
            adaptation_score = len(self.parameter_sets) / 5.0  # Max 5 regimes
            parameter_stability = self._calculate_parameter_stability(self.current_parameters)
            
            performance_score = self.parameter_sets.get(regime, 
                ParameterSet('', {}, 0.0, 0.0, 0, datetime.now())
            ).performance
            
            confidence = (adaptation_score * 0.3 + 
                         parameter_stability * 0.4 + 
                         min(performance_score / 2.0, 1.0) * 0.3)
            
            # Create signal
            signal = AdaptiveSignal(
                timestamp=data.index[i],
                indicator_value=indicator_value,
                optimal_parameters=self.current_parameters.copy(),
                adaptation_score=adaptation_score,
                regime_type=regime,
                volatility_factor=volatility_factor,
                parameter_stability=parameter_stability,
                performance_score=performance_score,
                confidence=confidence
            )
            
            results.append({
                'timestamp': signal.timestamp,
                'indicator_value': signal.indicator_value,
                'adaptation_score': signal.adaptation_score,
                'regime_type': signal.regime_type,
                'volatility_factor': signal.volatility_factor,
                'parameter_stability': signal.parameter_stability,
                'performance_score': signal.performance_score,
                'confidence': signal.confidence,
                'signal_strength': 'strong' if confidence > 0.7 else 'moderate' if confidence > 0.4 else 'weak',
                'parameter_period': self.current_parameters.get('period', 14),
                'regime_count': len(self.parameter_sets)
            })
        
        # Update internal arrays
        if results:
            self.adaptation_scores = np.array([r['adaptation_score'] for r in results])
            self.performance_scores = np.array([r['performance_score'] for r in results])
        
        return pd.DataFrame(results)
    
    def _apply_volatility_scaling(self, params: Dict[str, float], 
                                volatility_factor: float) -> Dict[str, float]:
        """Apply volatility-based parameter scaling."""
        scaled_params = params.copy()
        
        # Scale period-based parameters
        if 'period' in scaled_params:
            scaled_params['period'] = max(5, int(scaled_params['period'] / volatility_factor))
        
        if 'fast' in scaled_params:
            scaled_params['fast'] = max(3, int(scaled_params['fast'] / volatility_factor))
        
        if 'slow' in scaled_params:
            scaled_params['slow'] = max(10, int(scaled_params['slow'] / volatility_factor))
        
        # Scale threshold parameters
        if 'std_dev' in scaled_params:
            scaled_params['std_dev'] = scaled_params['std_dev'] * volatility_factor
        
        return scaled_params
    
    def _blend_parameters(self, current: Dict[str, float], new: Dict[str, float], 
                         rate: float) -> Dict[str, float]:
        """Blend current and new parameters with adaptation rate."""
        blended = {}
        
        for key in new.keys():
            if key in current:
                blended[key] = current[key] * (1 - rate) + new[key] * rate
            else:
                blended[key] = new[key]
        
        return blended
    
    def get_signals(self, data: pd.DataFrame) -> List[AdaptiveSignal]:
        """Get adaptive indicator signals."""
        df = self.calculate(data)
        signals = []
        
        for _, row in df.iterrows():
            signal = AdaptiveSignal(
                timestamp=row['timestamp'],
                indicator_value=row['indicator_value'],
                optimal_parameters={'period': row['parameter_period']},
                adaptation_score=row['adaptation_score'],
                regime_type=row['regime_type'],
                volatility_factor=row['volatility_factor'],
                parameter_stability=row['parameter_stability'],
                performance_score=row['performance_score'],
                confidence=row['confidence']
            )
            signals.append(signal)
        
        return signals
    
    def get_parameter_analysis(self) -> Dict[str, Any]:
        """Get comprehensive parameter analysis."""
        analysis = {
            'current_parameters': self.current_parameters,
            'regime_count': len(self.parameter_sets),
            'parameter_sets': {
                regime: {
                    'parameters': ps.parameters,
                    'performance': ps.performance,
                    'usage_count': ps.usage_count
                }
                for regime, ps in self.parameter_sets.items()
            },
            'adaptation_efficiency': np.mean(self.adaptation_scores) if len(self.adaptation_scores) > 0 else 0.0,
            'average_performance': np.mean(self.performance_scores) if len(self.performance_scores) > 0 else 0.0
        }
        
        return analysis
    
    def __str__(self) -> str:
        return f"AdaptiveIndicators(base={self.base_indicator}, period={self.period})"
