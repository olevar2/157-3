"""
Awesome Oscillator (AO) - Bill Williams Momentum Indicator
Measures momentum by comparing 5-period and 34-period simple moving averages of midpoint prices.
Used to identify momentum changes and potential reversal points.
"""

from typing import List, Dict, Any, Optional, Tuple
import numpy as np
import pandas as pd
from dataclasses import dataclass
from ..indicator_base import BaseIndicator, IndicatorResult, IndicatorSignal, SignalType, IndicatorType, MarketData

# Platform3 Winston-style Logging Integration
import sys
import os

# Platform3 Error Handling Integration
from shared.error_handling.platform3_error_system import ServiceError, EventEmitter, CircuitBreaker, ErrorSeverity, ErrorCategory
from shared.error_handling.base_service import BaseService

sys.path.append(os.path.join(os.path.dirname(__file__), '../../shared'))
from logging.platform3_logger import Platform3Logger, log_performance, LogMetadata


@dataclass
class AwesomeOscillatorConfig(BaseService):
    """Configuration for Awesome Oscillator"""
    short_period: int = 5
    long_period: int = 34
    signal_threshold: float = 0.0001  # Minimum value for signal generation
    divergence_lookback: int = 10


class AwesomeOscillator(BaseIndicator):
    """
    Awesome Oscillator Implementation
    
    The Awesome Oscillator is the difference between:
    - 5-period SMA of (high + low) / 2
    - 34-period SMA of (high + low) / 2
    
    Signals:
    - Zero line crossover (bullish/bearish)
    - Twin peaks (bullish/bearish divergence)
    - Saucer pattern (momentum acceleration)
    """
    
    def __init__(self, config: Optional[AwesomeOscillatorConfig] = None):
        super().__init__(IndicatorType.MOMENTUM)
        self.config = config or AwesomeOscillatorConfig()
        self.values: List[float] = []
        self.midpoints: List[float] = []
        self.short_sma: List[float] = []
        self.long_sma: List[float] = []
        
    def calculate(self, data: List[MarketData]) -> IndicatorResult:
        try:
        """Calculate Awesome Oscillator values"""
        try:
            if len(data) < self.config.long_period:
                return IndicatorResult(
                    success=False,
                    error=f"Insufficient data: need {self.config.long_period}, got {len(data)}"
                )
            
            # Calculate midpoints (high + low) / 2
            midpoints = [(candle.high + candle.low) / 2 for candle in data]
            
            # Calculate SMAs
            short_sma = self._calculate_sma(midpoints, self.config.short_period)
            long_sma = self._calculate_sma(midpoints, self.config.long_period)
            
            # Calculate AO values (short SMA - long SMA)
            ao_values = []
            for i in range(len(long_sma)):
                if i < len(short_sma):
                    ao_values.append(short_sma[i] - long_sma[i])
                else:
                    ao_values.append(0.0)
            
            # Store values for signal generation
            self.values = ao_values
            self.midpoints = midpoints
            self.short_sma = short_sma
            self.long_sma = long_sma
            
            # Generate signals
            signals = self._generate_signals(data, ao_values)
            
            return IndicatorResult(
                success=True,
                values={
                    'ao': ao_values,
                    'short_sma': short_sma,
                    'long_sma': long_sma,
                    'midpoints': midpoints
                },
                signals=signals,
                metadata={
                    'short_period': self.config.short_period,
                    'long_period': self.config.long_period,
                    'current_ao': ao_values[-1] if ao_values else 0,
                    'zero_line_position': 'above' if ao_values and ao_values[-1] > 0 else 'below'
                }
            )
            
        except Exception as e:
            return IndicatorResult(
                success=False,
                error=f"AO calculation failed: {str(e)}"
            )
    
    def _calculate_sma(self, values: List[float], period: int) -> List[float]:
        try:
        """Calculate Simple Moving Average"""
        sma_values = []
        for i in range(len(values)):
            if i >= period - 1:
                sma = sum(values[i - period + 1:i + 1]) / period
                sma_values.append(sma)
        return sma_values
    
    def _generate_signals(self, data: List[MarketData], ao_values: List[float]) -> List[IndicatorSignal]:
        try:
        """Generate trading signals based on AO analysis"""
        signals = []
        
        if len(ao_values) < 3:
            return signals
        
        # Zero line crossover signals
        self._detect_zero_line_crossover(ao_values, signals)
        
        # Twin peaks pattern
        self._detect_twin_peaks(ao_values, signals)
        
        # Saucer pattern
        self._detect_saucer_pattern(ao_values, signals)
        
        # Momentum acceleration
        self._detect_momentum_acceleration(ao_values, signals)
        
        return signals
    
    def _detect_zero_line_crossover(self, ao_values: List[float], signals: List[IndicatorSignal]):
        try:
        """Detect zero line crossover signals"""
        if len(ao_values) < 2:
            return
        
        current = ao_values[-1]
        previous = ao_values[-2]
        
        # Bullish crossover (from negative to positive)
        if previous <= 0 < current and abs(current) > self.config.signal_threshold:
            signals.append(IndicatorSignal(
                signal_type=SignalType.BUY,
                strength=0.7,
                confidence=0.8,
                metadata={
                    'pattern': 'zero_line_crossover_bullish',
                    'ao_value': current,
                    'crossover_strength': abs(current)
                }
            ))
        
        # Bearish crossover (from positive to negative)
        elif previous >= 0 > current and abs(current) > self.config.signal_threshold:
            signals.append(IndicatorSignal(
                signal_type=SignalType.SELL,
                strength=0.7,
                confidence=0.8,
                metadata={
                    'pattern': 'zero_line_crossover_bearish',
                    'ao_value': current,
                    'crossover_strength': abs(current)
                }
            ))
    
    def _detect_twin_peaks(self, ao_values: List[float], signals: List[IndicatorSignal]):
        try:
        """Detect twin peaks bullish/bearish divergence patterns"""
        if len(ao_values) < self.config.divergence_lookback:
            return
        
        recent_values = ao_values[-self.config.divergence_lookback:]
        
        # Look for twin peaks below zero line (bullish)
        if all(v < 0 for v in recent_values[-3:]):
            peaks = self._find_local_peaks(recent_values)
            if len(peaks) >= 2:
                first_peak = peaks[-2]
                second_peak = peaks[-1]
                
                # Second peak higher than first (bullish divergence)
                if second_peak > first_peak:
                    signals.append(IndicatorSignal(
                        signal_type=SignalType.BUY,
                        strength=0.8,
                        confidence=0.75,
                        metadata={
                            'pattern': 'twin_peaks_bullish',
                            'first_peak': first_peak,
                            'second_peak': second_peak,
                            'divergence_strength': second_peak - first_peak
                        }
                    ))
        
        # Look for twin peaks above zero line (bearish)
        elif all(v > 0 for v in recent_values[-3:]):
            peaks = self._find_local_peaks(recent_values, find_max=True)
            if len(peaks) >= 2:
                first_peak = peaks[-2]
                second_peak = peaks[-1]
                
                # Second peak lower than first (bearish divergence)
                if second_peak < first_peak:
                    signals.append(IndicatorSignal(
                        signal_type=SignalType.SELL,
                        strength=0.8,
                        confidence=0.75,
                        metadata={
                            'pattern': 'twin_peaks_bearish',
                            'first_peak': first_peak,
                            'second_peak': second_peak,
                            'divergence_strength': first_peak - second_peak
                        }
                    ))
    
    def _detect_saucer_pattern(self, ao_values: List[float], signals: List[IndicatorSignal]):
        try:
        """Detect saucer pattern - three consecutive bars forming a saucer shape"""
        if len(ao_values) < 3:
            return
        
        v1, v2, v3 = ao_values[-3], ao_values[-2], ao_values[-1]
        
        # Bullish saucer (all below zero, middle lowest, trending up)
        if v1 < 0 and v2 < 0 and v3 < 0 and v2 < v1 and v3 > v2:
            signals.append(IndicatorSignal(
                signal_type=SignalType.BUY,
                strength=0.6,
                confidence=0.7,
                metadata={
                    'pattern': 'saucer_bullish',
                    'saucer_depth': min(v1, v2, v3),
                    'momentum_change': v3 - v2
                }
            ))
        
        # Bearish saucer (all above zero, middle highest, trending down)
        elif v1 > 0 and v2 > 0 and v3 > 0 and v2 > v1 and v3 < v2:
            signals.append(IndicatorSignal(
                signal_type=SignalType.SELL,
                strength=0.6,
                confidence=0.7,
                metadata={
                    'pattern': 'saucer_bearish',
                    'saucer_height': max(v1, v2, v3),
                    'momentum_change': v2 - v3
                }
            ))
    
    def _detect_momentum_acceleration(self, ao_values: List[float], signals: List[IndicatorSignal]):
        try:
        """Detect momentum acceleration patterns"""
        if len(ao_values) < 5:
            return
        
        recent = ao_values[-5:]
        
        # Calculate momentum acceleration
        changes = [recent[i] - recent[i-1] for i in range(1, len(recent))]
        acceleration = [changes[i] - changes[i-1] for i in range(1, len(changes))]
        
        if len(acceleration) >= 2:
            current_accel = acceleration[-1]
            
            # Strong positive acceleration
            if current_accel > 0 and ao_values[-1] > ao_values[-2]:
                signals.append(IndicatorSignal(
                    signal_type=SignalType.BUY,
                    strength=0.5,
                    confidence=0.6,
                    metadata={
                        'pattern': 'momentum_acceleration_bullish',
                        'acceleration': current_accel,
                        'ao_trend': 'increasing'
                    }
                ))
            
            # Strong negative acceleration
            elif current_accel < 0 and ao_values[-1] < ao_values[-2]:
                signals.append(IndicatorSignal(
                    signal_type=SignalType.SELL,
                    strength=0.5,
                    confidence=0.6,
                    metadata={
                        'pattern': 'momentum_acceleration_bearish',
                        'acceleration': current_accel,
                        'ao_trend': 'decreasing'
                    }
                ))
    
    def _find_local_peaks(self, values: List[float], find_max: bool = False) -> List[float]:
        try:
        """Find local peaks (max or min) in the values"""
        peaks = []
        for i in range(1, len(values) - 1):
            if find_max:
                if values[i] > values[i-1] and values[i] > values[i+1]:
                    peaks.append(values[i])
            else:
                if values[i] < values[i-1] and values[i] < values[i+1]:
                    peaks.append(values[i])
        return peaks
    
    def get_signal_strength(self, current_value: float) -> float:
        try:
        """Calculate signal strength based on AO value and position"""
        if not self.values:
            return 0.0
        
        # Normalize strength based on recent volatility
        recent_values = self.values[-20:] if len(self.values) >= 20 else self.values
        if not recent_values:
            return 0.0
        
        volatility = np.std(recent_values)
        if volatility == 0:
            return 0.0
        
        # Strength increases with distance from zero line
        strength = min(abs(current_value) / (volatility * 2), 1.0)
        return strength



    def handle_service_error(self, error: Exception, context: Dict[str, Any] = None) -> None:
        """Handle service errors with proper event emission and logging"""
        try:
            service_error = ServiceError(
                message=str(error),
                code=f"{self.__class__.__name__.upper()}_ERROR",
                metadata={
                    "file_path": "engines/momentum/awesome_oscillator.py",
                    "context": context or {},
                    "timestamp": pd.Timestamp.now().isoformat(),
                    "service_name": self.__class__.__name__
                }
            )
            
            # Emit error event for monitoring
            self.emit('error', service_error)
            
            # Log error with correlation context
            if hasattr(self, 'logger'):
                self.logger.error(f"Service error in {self.__class__.__name__}: {str(error)}", extra={
                        "error_code": service_error.code,
                        "error_severity": service_error.severity.value,
                        "error_category": service_error.category.value,
                        "context": context
                    })
        except Exception as handling_error:
            # Fallback error handling
            print(f"Critical error in error handling: {handling_error}")
    
    def implement_circuit_breaker(self, service_name: str, failure_threshold: int = 5) -> CircuitBreaker:
        """Implement circuit breaker for external service calls"""
        return CircuitBreaker(
            service_name=service_name,
            failure_threshold=failure_threshold,
            recovery_timeout=30,
            on_failure=lambda error: self.emit('circuit_breaker_open', {'service': service_name, 'error': error})
        )
    
    def graceful_degradation(self, primary_function, fallback_function, context: str = "operation"):
        """Implement graceful degradation pattern"""
        try:
            return primary_function()
        except Exception as error:
            self.handle_service_error(error, {"context": context, "degradation": "fallback_used"})
            
            # Emit degradation event
            self.emit('service_degradation', {
                'context': context,
                'primary_error': str(error),
                'fallback_activated': True
            })
            
            return fallback_function()

def test_awesome_oscillator():
    """Test the Awesome Oscillator implementation"""
    # Create test data
    np.random.seed(42)
    test_data = []
    base_price = 100.0
    
    for i in range(50):
        # Generate realistic OHLC data
        trend = 0.1 * np.sin(i * 0.1)  # Sine wave trend
        noise = np.random.normal(0, 0.5)
        
        open_price = base_price + trend + noise
        close_price = open_price + np.random.normal(0, 0.3)
        high_price = max(open_price, close_price) + abs(np.random.normal(0, 0.2))
        low_price = min(open_price, close_price) - abs(np.random.normal(0, 0.2))
        volume = 1000 + np.random.randint(0, 500)
        
        test_data.append(MarketData(
            timestamp=i,
            open=open_price,
            high=high_price,
            low=low_price,
            close=close_price,
            volume=volume
        ))
        
        base_price = close_price
    
    # Test Awesome Oscillator
    ao = AwesomeOscillator()
    result = ao.calculate(test_data)
    
    print("=== AWESOME OSCILLATOR TEST ===")
    print(f"Success: {result.success}")
    if result.success:
        ao_values = result.values['ao']
        print(f"AO Values (last 5): {[round(v, 6) for v in ao_values[-5:]]}")
        print(f"Current AO: {round(ao_values[-1], 6)}")
        print(f"Zero Line Position: {result.metadata['zero_line_position']}")
        print(f"Number of signals: {len(result.signals)}")
        
        for i, signal in enumerate(result.signals[-3:]):  # Show last 3 signals
            print(f"Signal {i+1}: {signal.signal_type.value} - Strength: {signal.strength:.2f} - {signal.metadata.get('pattern', 'N/A')}")
    else:
        print(f"Error: {result.error}")
    
    return result.success


if __name__ == "__main__":
    test_awesome_oscillator()
