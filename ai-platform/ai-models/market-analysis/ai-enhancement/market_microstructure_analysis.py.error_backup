"""
Market Microstructure Analysis - Order Flow and Depth Analysis

This module implements advanced market microstructure analysis including
order flow analysis, market depth analysis, and liquidity measurement
for high-frequency trading insights and market impact assessment.

Mathematical Foundation:
- Order Flow Imbalance Calculation
- Volume at Price (VAP) Analysis
- Market Depth and Liquidity Metrics
- Tick-by-Tick Analysis Simulation
- Price Impact Models
- Market Maker Detection

Author: Platform3 Trading System
Version: 1.0.0 - AI Enhancement
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import warnings
from scipy import stats
from collections import defaultdict
from ..indicator_base import IndicatorBase

# Platform3 Winston-style Logging Integration
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '../../../../shared'))
from logging.platform3_logger import Platform3Logger, log_performance, LogMetadata

warnings.filterwarnings('ignore')

@dataclass
class MicrostructureSignal:
    """Signal generated by market microstructure analysis."""
    timestamp: datetime
    order_flow_imbalance: float
    liquidity_score: float
    market_depth_ratio: float
    price_impact_estimate: float
    volume_profile_poc: float  # Point of Control
    market_maker_presence: float
    tick_pressure: float
    bid_ask_pressure: float
    institutional_flow: float
    retail_flow: float

@dataclass
class OrderFlowMetrics:
    """Order flow analysis metrics."""
    buy_volume: float
    sell_volume: float
    imbalance_ratio: float
    aggressive_buy_ratio: float
    aggressive_sell_ratio: float
    passive_flow_ratio: float

@dataclass
class LiquidityMetrics:
    """Market liquidity metrics."""
    depth_bid: float
    depth_ask: float
    spread_cost: float
    market_impact: float
    liquidity_score: float
    resilience_score: float

class MarketMicrostructureAnalysis(IndicatorBase):
    """
    Market Microstructure Analysis Indicator
    
    Analyzes order flow, market depth, and liquidity characteristics
    to provide insights into market microstructure dynamics.
    """
    
    def __init__(self, 
                 period: int = 50,
                 tick_analysis_window: int = 100,
                 depth_levels: int = 10,
                 volume_profile_bins: int = 20,
                 liquidity_threshold: float = 0.01):
        """
        Initialize Market Microstructure Analysis.
        
        Args:
            period: Analysis period
            tick_analysis_window: Window for tick analysis
            depth_levels: Number of market depth levels to analyze
            volume_profile_bins: Number of bins for volume profile
            liquidity_threshold: Threshold for liquidity classification
        """
        super().__init__(period)
        self.tick_analysis_window = tick_analysis_window
        self.depth_levels = depth_levels
        self.volume_profile_bins = volume_profile_bins
        self.liquidity_threshold = liquidity_threshold
        
        # Microstructure data storage
        self.order_flow_history = []
        self.liquidity_history = []
        self.tick_data = []
        
        # Volume profile tracking
        self.volume_profiles = []
        self.poc_history = []  # Point of Control history
        
        # Market maker detection
        self.market_maker_signatures = []
        self.institutional_patterns = []
        
    def _simulate_tick_data(self, ohlcv: pd.DataFrame) -> List[Dict]:
        """
        Simulate tick data from OHLCV bars.
        
        This creates a realistic tick-by-tick simulation for microstructure analysis.
        """
        ticks = []
        
        for idx, row in ohlcv.iterrows():
            open_price, high_price, low_price, close_price = row['open'], row['high'], row['low'], row['close']
            volume = row['volume'] if 'volume' in row else 1000
            
            # Generate realistic price path within the bar
            num_ticks = max(10, int(volume / 1000))  # Simulate tick frequency
            
            # Create price path: open -> high/low -> close
            price_points = [open_price]
            
            # Add high and low points
            if high_price != open_price:
                price_points.append(high_price)
            if low_price != open_price and low_price != high_price:
                price_points.append(low_price)
            if close_price not in price_points:
                price_points.append(close_price)
            
            # Interpolate between points
            price_path = []
            for i in range(len(price_points) - 1):
                start_price = price_points[i]
                end_price = price_points[i + 1]
                steps = max(2, num_ticks // len(price_points))
                
                for j in range(steps):
                    ratio = j / (steps - 1) if steps > 1 else 0
                    price = start_price + (end_price - start_price) * ratio
                    price_path.append(price)
            
            # Distribute volume across ticks
            volume_per_tick = volume / len(price_path)
            
            for i, price in enumerate(price_path):
                # Simulate bid-ask spread (0.01% of price)
                spread = price * 0.0001
                bid_price = price - spread / 2
                ask_price = price + spread / 2
                
                # Simulate order flow direction
                direction = 1 if i > 0 and price > price_path[i-1] else -1 if i > 0 and price < price_path[i-1] else 0
                
                tick = {
                    'timestamp': idx,
                    'price': price,
                    'bid': bid_price,
                    'ask': ask_price,
                    'volume': volume_per_tick,
                    'direction': direction,  # 1=buy, -1=sell, 0=neutral
                    'spread': spread
                }
                
                ticks.append(tick)
        
        return ticks
    
    def _calculate_order_flow_imbalance(self, ticks: List[Dict]) -> OrderFlowMetrics:
        """Calculate order flow imbalance from tick data."""
        if not ticks:
            return OrderFlowMetrics(0, 0, 0, 0, 0, 0)
        
        buy_volume = sum(tick['volume'] for tick in ticks if tick['direction'] > 0)
        sell_volume = sum(tick['volume'] for tick in ticks if tick['direction'] < 0)
        neutral_volume = sum(tick['volume'] for tick in ticks if tick['direction'] == 0)
        total_volume = buy_volume + sell_volume + neutral_volume
        
        if total_volume == 0:
            return OrderFlowMetrics(0, 0, 0, 0, 0, 0)
        
        # Order flow imbalance
        imbalance_ratio = (buy_volume - sell_volume) / total_volume
        
        # Aggressive vs passive flow (simplified simulation)
        aggressive_buy_ratio = buy_volume * 0.7 / total_volume  # Assume 70% of buy volume is aggressive
        aggressive_sell_ratio = sell_volume * 0.7 / total_volume
        passive_flow_ratio = (neutral_volume + 0.3 * (buy_volume + sell_volume)) / total_volume
        
        return OrderFlowMetrics(
            buy_volume=buy_volume,
            sell_volume=sell_volume,
            imbalance_ratio=imbalance_ratio,
            aggressive_buy_ratio=aggressive_buy_ratio,
            aggressive_sell_ratio=aggressive_sell_ratio,
            passive_flow_ratio=passive_flow_ratio
        )
    
    def _analyze_market_depth(self, ticks: List[Dict]) -> LiquidityMetrics:
        """Analyze market depth and liquidity."""
        if not ticks:
            return LiquidityMetrics(0, 0, 0, 0, 0, 0)
        
        # Calculate average bid-ask spread
        spreads = [tick['spread'] for tick in ticks if tick['spread'] > 0]
        avg_spread = np.mean(spreads) if spreads else 0.0
        
        # Simulate market depth (simplified)
        prices = [tick['price'] for tick in ticks]
        volumes = [tick['volume'] for tick in ticks]
        
        avg_price = np.mean(prices)
        total_volume = sum(volumes)
        
        # Simulate depth levels
        depth_bid = total_volume * 0.6  # Assume 60% of volume on bid side
        depth_ask = total_volume * 0.4  # Assume 40% of volume on ask side
        
        # Price impact estimation (Kyle's lambda)
        price_changes = np.diff(prices)
        volume_changes = volumes[1:] if len(volumes) > 1 else [0]
        
        if len(price_changes) > 0 and len(volume_changes) > 0:
            # Linear regression: price_change = lambda * volume
            if np.var(volume_changes) > 0:
                price_impact = np.corrcoef(price_changes, volume_changes)[0, 1] * np.std(price_changes) / np.std(volume_changes)
            else:
                price_impact = 0.0
        else:
            price_impact = 0.0
        
        # Liquidity score (inverse of spread and price impact)
        spread_cost = avg_spread / avg_price if avg_price > 0 else 0.0
        liquidity_score = 1.0 / (1.0 + spread_cost + abs(price_impact))
        
        # Resilience score (how quickly market recovers from shocks)
        resilience_score = liquidity_score * 0.8  # Simplified
        
        return LiquidityMetrics(
            depth_bid=depth_bid,
            depth_ask=depth_ask,
            spread_cost=spread_cost,
            market_impact=abs(price_impact),
            liquidity_score=liquidity_score,
            resilience_score=resilience_score
        )
    
    def _calculate_volume_profile(self, ticks: List[Dict]) -> Tuple[float, Dict[float, float]]:
        """Calculate Volume at Price (VAP) profile."""
        if not ticks:
            return 0.0, {}
        
        # Create price bins
        prices = [tick['price'] for tick in ticks]
        min_price, max_price = min(prices), max(prices)
        
        if min_price == max_price:
            return min_price, {min_price: sum(tick['volume'] for tick in ticks)}
        
        bin_size = (max_price - min_price) / self.volume_profile_bins
        volume_profile = defaultdict(float)
        
        # Aggregate volume by price level
        for tick in ticks:
            price_bin = int((tick['price'] - min_price) / bin_size) * bin_size + min_price
            volume_profile[price_bin] += tick['volume']
        
        # Find Point of Control (POC) - price level with highest volume
        poc_price = max(volume_profile.items(), key=lambda x: x[1])[0] if volume_profile else 0.0
        
        return poc_price, dict(volume_profile)
    
    def _detect_market_maker_activity(self, ticks: List[Dict]) -> float:
        """Detect market maker presence and activity."""
        if len(ticks) < 10:
            return 0.0
        
        # Market maker indicators:
        # 1. High frequency of small orders
        # 2. Consistent bid-ask presence
        # 3. Mean-reverting behavior
        
        volumes = [tick['volume'] for tick in ticks]
        avg_volume = np.mean(volumes)
        small_order_ratio = sum(1 for v in volumes if v < avg_volume * 0.5) / len(volumes)
        
        # Bid-ask consistency (simplified)
        spreads = [tick['spread'] for tick in ticks]
        spread_consistency = 1.0 - np.std(spreads) / (np.mean(spreads) + 1e-8)
        
        # Mean reversion tendency
        prices = [tick['price'] for tick in ticks]
        price_changes = np.diff(prices)
        
        if len(price_changes) > 1:
            # Autocorrelation of price changes (negative indicates mean reversion)
            autocorr = np.corrcoef(price_changes[:-1], price_changes[1:])[0, 1]
            mean_reversion_score = max(0, -autocorr)  # Convert negative correlation to positive score
        else:
            mean_reversion_score = 0.0
        
        # Combine indicators
        market_maker_score = (
            small_order_ratio * 0.4 +
            spread_consistency * 0.3 +
            mean_reversion_score * 0.3
        )
        
        return min(market_maker_score, 1.0)
    
    def _calculate_tick_pressure(self, ticks: List[Dict]) -> float:
        """Calculate tick pressure (momentum in tick data)."""
        if len(ticks) < 2:
            return 0.0
        
        # Calculate tick-by-tick pressure
        up_ticks = sum(1 for i in range(1, len(ticks)) 
                      if ticks[i]['price'] > ticks[i-1]['price'])
        down_ticks = sum(1 for i in range(1, len(ticks)) 
                        if ticks[i]['price'] < ticks[i-1]['price'])
        
        total_ticks = up_ticks + down_ticks
        
        if total_ticks == 0:
            return 0.0
        
        tick_pressure = (up_ticks - down_ticks) / total_ticks
        return tick_pressure
    
    def _analyze_institutional_vs_retail_flow(self, ticks: List[Dict]) -> Tuple[float, float]:
        """Analyze institutional vs retail order flow."""
        if not ticks:
            return 0.0, 0.0
        
        volumes = [tick['volume'] for tick in ticks]
        avg_volume = np.mean(volumes)
        
        # Classify orders by size (simplified heuristic)
        large_orders = [v for v in volumes if v > avg_volume * 2]  # Institutional
        small_orders = [v for v in volumes if v <= avg_volume * 2]  # Retail
        
        total_volume = sum(volumes)
        institutional_volume = sum(large_orders)
        retail_volume = sum(small_orders)
        
        institutional_flow = institutional_volume / total_volume if total_volume > 0 else 0.0
        retail_flow = retail_volume / total_volume if total_volume > 0 else 0.0
        
        return institutional_flow, retail_flow
    
    def _calculate_bid_ask_pressure(self, ticks: List[Dict]) -> float:
        """Calculate bid-ask pressure."""
        if not ticks:
            return 0.0
        
        # Analyze order flow direction relative to bid-ask
        buy_pressure = sum(tick['volume'] for tick in ticks if tick['direction'] > 0)
        sell_pressure = sum(tick['volume'] for tick in ticks if tick['direction'] < 0)
        
        total_pressure = buy_pressure + sell_pressure
        
        if total_pressure == 0:
            return 0.0
        
        bid_ask_pressure = (buy_pressure - sell_pressure) / total_pressure
        return bid_ask_pressure
    
    def calculate(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate market microstructure analysis.
        
        Args:
            data: DataFrame with OHLCV data
            
        Returns:
            DataFrame with microstructure signals
        """
        if len(data) < self.period:
            return pd.DataFrame()
        
        results = []
        
        for i in range(self.period, len(data)):
            window_data = data.iloc[i-self.period:i+1]
            
            # Simulate tick data for this window
            ticks = self._simulate_tick_data(window_data)
            
            # Limit to recent ticks for analysis
            recent_ticks = ticks[-self.tick_analysis_window:] if len(ticks) > self.tick_analysis_window else ticks
            
            # Calculate order flow metrics
            order_flow = self._calculate_order_flow_imbalance(recent_ticks)
            
            # Calculate liquidity metrics
            liquidity = self._analyze_market_depth(recent_ticks)
            
            # Calculate volume profile
            poc_price, volume_profile = self._calculate_volume_profile(recent_ticks)
            
            # Detect market maker activity
            market_maker_presence = self._detect_market_maker_activity(recent_ticks)
            
            # Calculate tick pressure
            tick_pressure = self._calculate_tick_pressure(recent_ticks)
            
            # Calculate bid-ask pressure
            bid_ask_pressure = self._calculate_bid_ask_pressure(recent_ticks)
            
            # Analyze institutional vs retail flow
            institutional_flow, retail_flow = self._analyze_institutional_vs_retail_flow(recent_ticks)
            
            # Calculate derived metrics
            market_depth_ratio = liquidity.depth_bid / (liquidity.depth_ask + 1e-8)
            
            # Normalize POC relative to current price
            current_price = data.iloc[i]['close']
            volume_profile_poc = (poc_price - current_price) / current_price if current_price > 0 else 0.0
            
            # Create signal
            signal = MicrostructureSignal(
                timestamp=data.index[i],
                order_flow_imbalance=order_flow.imbalance_ratio,
                liquidity_score=liquidity.liquidity_score,
                market_depth_ratio=market_depth_ratio,
                price_impact_estimate=liquidity.market_impact,
                volume_profile_poc=volume_profile_poc,
                market_maker_presence=market_maker_presence,
                tick_pressure=tick_pressure,
                bid_ask_pressure=bid_ask_pressure,
                institutional_flow=institutional_flow,
                retail_flow=retail_flow
            )
            
            results.append({
                'timestamp': signal.timestamp,
                'order_flow_imbalance': signal.order_flow_imbalance,
                'liquidity_score': signal.liquidity_score,
                'market_depth_ratio': signal.market_depth_ratio,
                'price_impact_estimate': signal.price_impact_estimate,
                'volume_profile_poc': signal.volume_profile_poc,
                'market_maker_presence': signal.market_maker_presence,
                'tick_pressure': signal.tick_pressure,
                'bid_ask_pressure': signal.bid_ask_pressure,
                'institutional_flow': signal.institutional_flow,
                'retail_flow': signal.retail_flow,
                'microstructure_score': (liquidity.liquidity_score * 0.3 + 
                                       (1 - abs(order_flow.imbalance_ratio)) * 0.3 +
                                       market_maker_presence * 0.2 +
                                       (1 - liquidity.market_impact) * 0.2),
                'flow_dominance': 'institutional' if institutional_flow > retail_flow else 'retail',
                'market_condition': 'liquid' if liquidity.liquidity_score > 0.7 else 'illiquid'
            })
            
            # Store for historical analysis
            self.order_flow_history.append(order_flow)
            self.liquidity_history.append(liquidity)
            self.poc_history.append(poc_price)
            
            # Limit history size
            if len(self.order_flow_history) > 1000:
                self.order_flow_history.pop(0)
                self.liquidity_history.pop(0)
                self.poc_history.pop(0)
        
        return pd.DataFrame(results)
    
    def get_signals(self, data: pd.DataFrame) -> List[MicrostructureSignal]:
        """Get microstructure signals."""
        df = self.calculate(data)
        signals = []
        
        for _, row in df.iterrows():
            signal = MicrostructureSignal(
                timestamp=row['timestamp'],
                order_flow_imbalance=row['order_flow_imbalance'],
                liquidity_score=row['liquidity_score'],
                market_depth_ratio=row['market_depth_ratio'],
                price_impact_estimate=row['price_impact_estimate'],
                volume_profile_poc=row['volume_profile_poc'],
                market_maker_presence=row['market_maker_presence'],
                tick_pressure=row['tick_pressure'],
                bid_ask_pressure=row['bid_ask_pressure'],
                institutional_flow=row['institutional_flow'],
                retail_flow=row['retail_flow']
            )
            signals.append(signal)
        
        return signals
    
    def get_microstructure_analysis(self) -> Dict[str, Any]:
        """Get comprehensive microstructure analysis."""
        if not self.order_flow_history:
            return {}
        
        analysis = {
            'avg_order_flow_imbalance': np.mean([of.imbalance_ratio for of in self.order_flow_history]),
            'avg_liquidity_score': np.mean([liq.liquidity_score for liq in self.liquidity_history]),
            'avg_market_impact': np.mean([liq.market_impact for liq in self.liquidity_history]),
            'poc_volatility': np.std(self.poc_history) if len(self.poc_history) > 1 else 0.0,
            'order_flow_persistence': self._calculate_persistence([of.imbalance_ratio for of in self.order_flow_history]),
            'liquidity_trend': self._calculate_trend([liq.liquidity_score for liq in self.liquidity_history]),
            'market_maker_frequency': np.mean(self.market_maker_signatures) if self.market_maker_signatures else 0.0
        }
        
        return analysis
    
    def _calculate_persistence(self, series: List[float]) -> float:
        """Calculate persistence (Hurst-like measure) of a series."""
        if len(series) < 10:
            return 0.5
        
        # Simplified persistence calculation
        changes = np.diff(series)
        positive_runs = []
        negative_runs = []
        
        current_run = 0
        current_sign = 0
        
        for change in changes:
            if change > 0:
                if current_sign > 0:
                    current_run += 1
                else:
                    if current_run > 0:
                        negative_runs.append(current_run)
                    current_run = 1
                    current_sign = 1
            elif change < 0:
                if current_sign < 0:
                    current_run += 1
                else:
                    if current_run > 0:
                        positive_runs.append(current_run)
                    current_run = 1
                    current_sign = -1
        
        # Add final run
        if current_sign > 0:
            positive_runs.append(current_run)
        elif current_sign < 0:
            negative_runs.append(current_run)
        
        all_runs = positive_runs + negative_runs
        avg_run_length = np.mean(all_runs) if all_runs else 1.0
        
        # Convert to persistence measure (0.5 = random, >0.5 = persistent, <0.5 = mean-reverting)
        persistence = min(0.5 + (avg_run_length - 1) / 20, 1.0)
        
        return persistence
    
    def _calculate_trend(self, series: List[float]) -> str:
        """Calculate trend direction of a series."""
        if len(series) < 5:
            return 'stable'
        
        # Linear regression slope
        x = np.arange(len(series))
        slope = np.polyfit(x, series, 1)[0]
        
        if slope > 0.001:
            return 'improving'
        elif slope < -0.001:
            return 'deteriorating'
        else:
            return 'stable'
    
    def __str__(self) -> str:
        return f"MarketMicrostructureAnalysis(period={self.period}, depth_levels={self.depth_levels})"
