# -*- coding: utf-8 -*-
"""
Stochastic Oscillator Indicator

The Stochastic Oscillator is a momentum indicator that compares a particular closing price
of a security to a range of its prices over a certain period. It consists of two lines:
%K (fast stochastic) and %D (slow stochastic), oscillating between 0 and 100.

Key Features:
- Fast %K and slow %D calculations
- Customizable periods and smoothing
- Overbought/oversold level detection
- Crossover signal generation
- Divergence analysis capabilities
- Multiple stochastic variants (Fast, Slow, Full)

Author: Platform3 Analytics Team
Version: 1.0.0
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Union, NamedTuple
from dataclasses import dataclass
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class StochasticSignal(Enum):
    """Stochastic signal types"""
    OVERSOLD_BOUNCE = "oversold_bounce"
    OVERBOUGHT_REVERSAL = "overbought_reversal"
    BULLISH_CROSSOVER = "bullish_crossover"
    BEARISH_CROSSOVER = "bearish_crossover"
    BULLISH_DIVERGENCE = "bullish_divergence"
    BEARISH_DIVERGENCE = "bearish_divergence"
    MOMENTUM_SHIFT = "momentum_shift"
    NEUTRAL = "neutral"

class StochasticType(Enum):
    """Types of stochastic calculations"""
    FAST = "fast"      # %K raw, %D smoothed %K
    SLOW = "slow"      # %K smoothed, %D smoothed %K
    FULL = "full"      # Fully customizable smoothing

@dataclass
class StochasticResult:
    """Stochastic calculation result"""
    k_percent: float
    d_percent: float
    signal: StochasticSignal
    strength: float
    overbought_level: float
    oversold_level: float
    divergence_detected: bool
    momentum_direction: str

class StochasticData(NamedTuple):
    """Stochastic data structure"""
    k_percent: np.ndarray
    d_percent: np.ndarray

class Stochastic:
    """
    Stochastic Oscillator Technical Indicator
    
    The Stochastic Oscillator compares the closing price to the price range
    over a given time period. It generates values between 0 and 100.
    """
    
    def __init__(self,
                 k_period: int = 14,
                 d_period: int = 3,
                 k_smooth: int = 1,
                 overbought_level: float = 80.0,
                 oversold_level: float = 20.0,
                 stoch_type: StochasticType = StochasticType.FAST):
        """
        Initialize Stochastic indicator
        
        Args:
            k_period: Period for %K calculation (default: 14)
            d_period: Period for %D smoothing (default: 3)
            k_smooth: Period for %K smoothing (default: 1 for fast)
            overbought_level: Overbought threshold (default: 80)
            oversold_level: Oversold threshold (default: 20)
            stoch_type: Type of stochastic calculation
        """
        self.k_period = k_period
        self.d_period = d_period
        self.k_smooth = k_smooth
        self.overbought_level = overbought_level
        self.oversold_level = oversold_level
        self.stoch_type = stoch_type
        
        # Historical data for analysis
        self.price_history = []
        self.stoch_history = []
        
        logger.info(f"âœ… Stochastic indicator initialized (K={k_period}, D={d_period}, type={stoch_type.value})")

    def calculate(self, highs: np.ndarray, lows: np.ndarray, closes: np.ndarray) -> StochasticData:
        """
        Calculate Stochastic oscillator values
        
        Args:
            highs: High prices
            lows: Low prices
            closes: Closing prices
            
        Returns:
            StochasticData with %K and %D values
        """
        try:
            if len(highs) != len(lows) or len(highs) != len(closes):
                raise ValueError("High, low, and close arrays must have the same length")
            
            if len(highs) < self.k_period:
                # Return neutral values if insufficient data
                neutral = np.full(len(highs), 50.0)
                return StochasticData(neutral, neutral)
            
            # Calculate raw %K
            k_percent = self._calculate_raw_k(highs, lows, closes)
            
            # Apply smoothing based on stochastic type
            if self.stoch_type == StochasticType.FAST:
                # Fast: %K is raw, %D is smoothed %K
                if self.k_smooth > 1:
                    k_percent = self._sma(k_percent, self.k_smooth)
                d_percent = self._sma(k_percent, self.d_period)
            elif self.stoch_type == StochasticType.SLOW:
                # Slow: %K is smoothed, %D is smoothed %K
                k_percent = self._sma(k_percent, self.k_smooth)
                d_percent = self._sma(k_percent, self.d_period)
            else:  # FULL
                # Full: Customizable smoothing
                if self.k_smooth > 1:
                    k_percent = self._sma(k_percent, self.k_smooth)
                d_percent = self._sma(k_percent, self.d_period)
            
            return StochasticData(k_percent, d_percent)
            
        except Exception as e:
            logger.error(f"Error calculating Stochastic: {e}")
            neutral = np.full(len(highs), 50.0)
            return StochasticData(neutral, neutral)

    def _calculate_raw_k(self, highs: np.ndarray, lows: np.ndarray, closes: np.ndarray) -> np.ndarray:
        """Calculate raw %K values"""
        try:
            k_values = np.full(len(closes), 50.0)
            
            for i in range(self.k_period - 1, len(closes)):
                # Get the period window
                period_highs = highs[i - self.k_period + 1:i + 1]
                period_lows = lows[i - self.k_period + 1:i + 1]
                current_close = closes[i]
                
                # Calculate highest high and lowest low
                highest_high = np.max(period_highs)
                lowest_low = np.min(period_lows)
                
                # Calculate %K
                if highest_high != lowest_low:
                    k_values[i] = ((current_close - lowest_low) / (highest_high - lowest_low)) * 100
                else:
                    k_values[i] = 50.0  # Neutral when no range
            
            return k_values
            
        except Exception:
            return np.full(len(closes), 50.0)

    def _sma(self, data: np.ndarray, period: int) -> np.ndarray:
        """Simple Moving Average"""
        try:
            return pd.Series(data).rolling(window=period, min_periods=1).mean().values
        except Exception:
            return data

    def analyze(self, highs: np.ndarray, lows: np.ndarray, closes: np.ndarray) -> StochasticResult:
        """
        Comprehensive Stochastic analysis with signal generation
        
        Args:
            highs: High prices
            lows: Low prices
            closes: Closing prices
            
        Returns:
            StochasticResult with comprehensive analysis
        """
        try:
            # Calculate Stochastic values
            stoch_data = self.calculate(highs, lows, closes)
            
            # Get current values
            current_k = stoch_data.k_percent[-1]
            current_d = stoch_data.d_percent[-1]
            
            # Determine signal
            signal = self._determine_signal(stoch_data, closes, highs, lows)
            
            # Calculate signal strength
            strength = self._calculate_strength(current_k, current_d)
            
            # Check for divergence
            divergence_detected = self._detect_divergence(stoch_data, closes, highs, lows)
            
            # Determine momentum direction
            momentum_direction = self._get_momentum_direction(stoch_data)
            
            return StochasticResult(
                k_percent=current_k,
                d_percent=current_d,
                signal=signal,
                strength=strength,
                overbought_level=self.overbought_level,
                oversold_level=self.oversold_level,
                divergence_detected=divergence_detected,
                momentum_direction=momentum_direction
            )
            
        except Exception as e:
            logger.error(f"Error in Stochastic analysis: {e}")
            return StochasticResult(50.0, 50.0, StochasticSignal.NEUTRAL, 0.0,
                                  self.overbought_level, self.oversold_level, False, "neutral")

    def _determine_signal(self, stoch_data: StochasticData, closes: np.ndarray,
                         highs: np.ndarray, lows: np.ndarray) -> StochasticSignal:
        """Determine Stochastic signal based on current conditions"""
        try:
            k_percent = stoch_data.k_percent
            d_percent = stoch_data.d_percent
            
            if len(k_percent) < 2:
                return StochasticSignal.NEUTRAL
            
            current_k = k_percent[-1]
            prev_k = k_percent[-2]
            current_d = d_percent[-1]
            prev_d = d_percent[-2]
            
            # Check for crossovers
            if prev_k <= prev_d and current_k > current_d:
                if current_k <= self.oversold_level:
                    return StochasticSignal.OVERSOLD_BOUNCE
                else:
                    return StochasticSignal.BULLISH_CROSSOVER
            elif prev_k >= prev_d and current_k < current_d:
                if current_k >= self.overbought_level:
                    return StochasticSignal.OVERBOUGHT_REVERSAL
                else:
                    return StochasticSignal.BEARISH_CROSSOVER
            
            # Check for divergences
            if self._detect_bullish_divergence(stoch_data, closes, lows):
                return StochasticSignal.BULLISH_DIVERGENCE
            elif self._detect_bearish_divergence(stoch_data, closes, highs):
                return StochasticSignal.BEARISH_DIVERGENCE
            
            # Check for momentum shifts
            if len(k_percent) >= 5:
                k_trend = np.polyfit(range(5), k_percent[-5:], 1)[0]
                if abs(k_trend) > 3:  # Significant trend change
                    return StochasticSignal.MOMENTUM_SHIFT
            
            return StochasticSignal.NEUTRAL
            
        except Exception:
            return StochasticSignal.NEUTRAL

    def _calculate_strength(self, k_value: float, d_value: float) -> float:
        """Calculate signal strength based on Stochastic values"""
        try:
            # Strength based on position relative to overbought/oversold levels
            if k_value >= self.overbought_level:
                strength = (k_value - self.overbought_level) / (100 - self.overbought_level)
            elif k_value <= self.oversold_level:
                strength = (self.oversold_level - k_value) / self.oversold_level
            else:
                # Neutral zone - strength based on distance from 50
                strength = abs(k_value - 50) / 50
            
            # Factor in %D confirmation
            k_d_diff = abs(k_value - d_value)
            confirmation_factor = 1.0 - (k_d_diff / 100)  # Higher when %K and %D are close
            
            final_strength = strength * confirmation_factor
            return max(0.0, min(1.0, final_strength))
            
        except Exception:
            return 0.0

    def _detect_divergence(self, stoch_data: StochasticData, closes: np.ndarray,
                          highs: np.ndarray, lows: np.ndarray) -> bool:
        """Detect any type of divergence"""
        try:
            bullish_div = self._detect_bullish_divergence(stoch_data, closes, lows)
            bearish_div = self._detect_bearish_divergence(stoch_data, closes, highs)
            return bullish_div or bearish_div
        except Exception:
            return False

    def _detect_bullish_divergence(self, stoch_data: StochasticData, closes: np.ndarray,
                                  lows: np.ndarray) -> bool:
        """Detect bullish divergence (price makes lower low, Stochastic makes higher low)"""
        try:
            if len(closes) < 20:
                return False
            
            k_percent = stoch_data.k_percent
            
            # Find recent lows
            recent_period = min(20, len(closes))
            recent_lows = lows[-recent_period:]
            recent_k = k_percent[-recent_period:]
            
            # Find local minima
            price_lows = self._find_local_minima(recent_lows)
            stoch_lows = self._find_local_minima(recent_k)
            
            if len(price_lows) >= 2 and len(stoch_lows) >= 2:
                # Check for divergence pattern
                latest_price_low = price_lows[-1]
                prev_price_low = price_lows[-2]
                latest_stoch_low = stoch_lows[-1]
                prev_stoch_low = stoch_lows[-2]
                
                price_lower = recent_lows[latest_price_low] < recent_lows[prev_price_low]
                stoch_higher = recent_k[latest_stoch_low] > recent_k[prev_stoch_low]
                
                return price_lower and stoch_higher
            
            return False
            
        except Exception:
            return False

    def _detect_bearish_divergence(self, stoch_data: StochasticData, closes: np.ndarray,
                                  highs: np.ndarray) -> bool:
        """Detect bearish divergence (price makes higher high, Stochastic makes lower high)"""
        try:
            if len(closes) < 20:
                return False
            
            k_percent = stoch_data.k_percent
            
            # Find recent highs
            recent_period = min(20, len(closes))
            recent_highs = highs[-recent_period:]
            recent_k = k_percent[-recent_period:]
            
            # Find local maxima
            price_highs = self._find_local_maxima(recent_highs)
            stoch_highs = self._find_local_maxima(recent_k)
            
            if len(price_highs) >= 2 and len(stoch_highs) >= 2:
                # Check for divergence pattern
                latest_price_high = price_highs[-1]
                prev_price_high = price_highs[-2]
                latest_stoch_high = stoch_highs[-1]
                prev_stoch_high = stoch_highs[-2]
                
                price_higher = recent_highs[latest_price_high] > recent_highs[prev_price_high]
                stoch_lower = recent_k[latest_stoch_high] < recent_k[prev_stoch_high]
                
                return price_higher and stoch_lower
            
            return False
            
        except Exception:
            return False

    def _find_local_minima(self, data: np.ndarray, window: int = 3) -> List[int]:
        """Find local minima in data"""
        minima = []
        for i in range(window, len(data) - window):
            if all(data[i] <= data[i-j] for j in range(1, window+1)) and \
               all(data[i] <= data[i+j] for j in range(1, window+1)):
                minima.append(i)
        return minima

    def _find_local_maxima(self, data: np.ndarray, window: int = 3) -> List[int]:
        """Find local maxima in data"""
        maxima = []
        for i in range(window, len(data) - window):
            if all(data[i] >= data[i-j] for j in range(1, window+1)) and \
               all(data[i] >= data[i+j] for j in range(1, window+1)):
                maxima.append(i)
        return maxima

    def _get_momentum_direction(self, stoch_data: StochasticData) -> str:
        """Determine momentum direction based on Stochastic trend"""
        try:
            k_percent = stoch_data.k_percent
            
            if len(k_percent) < 3:
                return "neutral"
            
            recent_k = k_percent[-3:]
            trend = np.polyfit(range(len(recent_k)), recent_k, 1)[0]
            
            if trend > 2:
                return "bullish"
            elif trend < -2:
                return "bearish"
            else:
                return "neutral"
                
        except Exception:
            return "neutral"

    def get_trading_signals(self, highs: np.ndarray, lows: np.ndarray, closes: np.ndarray) -> Dict:
        """
        Get comprehensive trading signals based on Stochastic analysis
        
        Returns:
            Dictionary with trading recommendations
        """
        try:
            analysis = self.analyze(highs, lows, closes)
            stoch_data = self.calculate(highs, lows, closes)
            
            signals = {
                'primary_signal': analysis.signal.value,
                'signal_strength': analysis.strength,
                'k_percent': analysis.k_percent,
                'd_percent': analysis.d_percent,
                'momentum_direction': analysis.momentum_direction,
                'divergence_detected': analysis.divergence_detected,
                'overbought': analysis.k_percent >= self.overbought_level,
                'oversold': analysis.k_percent <= self.oversold_level,
                'bullish_crossover': analysis.k_percent > analysis.d_percent,
                'recommendations': self._generate_recommendations(analysis, stoch_data)
            }
            
            return signals
            
        except Exception as e:
            logger.error(f"Error generating trading signals: {e}")
            return {'primary_signal': 'neutral', 'signal_strength': 0.0}

    def _generate_recommendations(self, analysis: StochasticResult, stoch_data: StochasticData) -> List[str]:
        """Generate trading recommendations based on Stochastic analysis"""
        recommendations = []
        
        try:
            if analysis.signal == StochasticSignal.OVERSOLD_BOUNCE:
                recommendations.append("Strong buy signal - Stochastic oversold bounce detected")
            elif analysis.signal == StochasticSignal.OVERBOUGHT_REVERSAL:
                recommendations.append("Strong sell signal - Stochastic overbought reversal detected")
            elif analysis.signal == StochasticSignal.BULLISH_CROSSOVER:
                recommendations.append("Buy signal - Stochastic bullish crossover detected")
            elif analysis.signal == StochasticSignal.BEARISH_CROSSOVER:
                recommendations.append("Sell signal - Stochastic bearish crossover detected")
            elif analysis.signal == StochasticSignal.BULLISH_DIVERGENCE:
                recommendations.append("Strong buy signal - Bullish divergence detected")
            elif analysis.signal == StochasticSignal.BEARISH_DIVERGENCE:
                recommendations.append("Strong sell signal - Bearish divergence detected")
            elif analysis.signal == StochasticSignal.MOMENTUM_SHIFT:
                if analysis.momentum_direction == "bullish":
                    recommendations.append("Momentum shifting bullish - Consider long positions")
                elif analysis.momentum_direction == "bearish":
                    recommendations.append("Momentum shifting bearish - Consider short positions")
            
            # Additional recommendations based on levels
            if analysis.k_percent > 90:
                recommendations.append("Extreme overbought - High probability of reversal")
            elif analysis.k_percent < 10:
                recommendations.append("Extreme oversold - High probability of bounce")
            elif 40 <= analysis.k_percent <= 60:
                recommendations.append("Stochastic neutral - Wait for clearer signals")
            
            # %K and %D relationship recommendations
            if abs(analysis.k_percent - analysis.d_percent) < 2:
                recommendations.append("Strong signal confirmation - %K and %D converging")
            elif abs(analysis.k_percent - analysis.d_percent) > 10:
                recommendations.append("Weak signal - %K and %D diverging")
            
            return recommendations
            
        except Exception:
            return ["Unable to generate recommendations"]
