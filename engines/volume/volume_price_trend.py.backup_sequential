# -*- coding: utf-8 -*-
"""
Volume Price Trend (VPT) - Advanced Volume Momentum Indicator
===============================================================

A sophisticated implementation of the Volume Price Trend indicator that combines
price movement with volume to identify the strength and direction of price trends.
VPT accumulates volume based on price percentage changes, providing insights into
whether volume is supporting price movements.

Key Features:
- Volume-weighted price momentum analysis
- Trend confirmation and divergence detection
- Accumulation/distribution pattern recognition
- Volume flow analysis
- Breakout confirmation signals
- Multi-timeframe volume coordination
- Smart money flow detection

Humanitarian Use:
Enables precise volume-based trend confirmation for maximum profit generation
while maintaining ethical trading practices for humanitarian funding.
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum
import logging
from datetime import datetime, timedelta

from ..indicator_base import IndicatorBase, IndicatorConfig, IndicatorSignal, SignalStrength, MarketCondition

logger = logging.getLogger(__name__)

class VPTTrendState(Enum):
    """VPT trend states"""
    STRONG_ACCUMULATION = "strong_accumulation"
    WEAK_ACCUMULATION = "weak_accumulation"
    STRONG_DISTRIBUTION = "strong_distribution"
    WEAK_DISTRIBUTION = "weak_distribution"
    NEUTRAL_FLOW = "neutral_flow"

class VPTSignalType(Enum):
    """VPT signal types"""
    BULLISH_DIVERGENCE = "bullish_divergence"
    BEARISH_DIVERGENCE = "bearish_divergence"
    VOLUME_BREAKOUT = "volume_breakout"
    TREND_CONFIRMATION = "trend_confirmation"
    FLOW_REVERSAL = "flow_reversal"

@dataclass
class VPTConfig(IndicatorConfig):
    """Configuration for Volume Price Trend"""
    # Core VPT settings
    smoothing_period: int = 14
    volume_ma_period: int = 20
    price_change_threshold: float = 0.001  # 0.1% minimum price change
    
    # Signal detection settings
    divergence_lookback: int = 20
    breakout_threshold: float = 2.0  # Standard deviations for breakouts
    trend_confirmation_period: int = 5
    
    # Volume analysis settings
    volume_surge_threshold: float = 1.5  # Volume surge multiplier
    volume_dryup_threshold: float = 0.5   # Volume dry-up threshold
    
    # Advanced features
    adaptive_smoothing: bool = True
    smart_money_detection: bool = True
    flow_strength_analysis: bool = True
    multi_timeframe_sync: bool = True

@dataclass
class VPTVolumeFlow:
    """Volume flow analysis"""
    flow_direction: str  # "bullish", "bearish", "neutral"
    flow_strength: float  # 0.0 to 1.0
    volume_quality: float  # Quality of volume (surge vs normal)
    accumulation_rate: float  # Rate of accumulation/distribution
    smart_money_activity: bool

@dataclass
class VPTAnalysis:
    """Comprehensive VPT analysis results"""
    trend_state: VPTTrendState
    vpt_value: float
    vpt_change: float
    vpt_momentum: float
    volume_flow: VPTVolumeFlow
    price_volume_sync: float  # How well price and volume align
    breakout_probability: float
    divergence_strength: float
    signal_quality: float

class VolumePriceTrend(IndicatorBase[VPTConfig]):
    """
    Advanced Volume Price Trend implementation
    
    VPT = Previous VPT + (Volume multiply (Close - Previous Close) / Previous Close)
    
    The VPT indicator uses volume and price data to determine the direction
    and strength of money flow, helping identify trend confirmations and
    potential reversals through volume analysis.
    """
    
    def __init__(self, config: VPTConfig):
        super().__init__(config)
        self.vpt_values: List[float] = []
        self.vpt_smoothed: List[float] = []
        self.volume_ma: List[float] = []
        self.price_changes: List[float] = []
        self.volume_ratios: List[float] = []
        
        # Pattern tracking
        self.divergence_points: List[Tuple[int, str, float]] = []
        self.breakout_points: List[Tuple[int, str, float]] = []
        self.flow_reversals: List[Tuple[int, str]] = []
        
        # Analysis state
        self.last_vpt: float = 0.0
        self.trend_strength: float = 0.0
        self.volume_quality_score: float = 0.5
        
    def _calculate_vpt(self, close: float, prev_close: float, volume: float) -> float:
        """Calculate VPT value"""
        if prev_close <= 0:
            return self.last_vpt
        
        price_change_pct = (close - prev_close) / prev_close
        
        # Only calculate if price change exceeds threshold
        if abs(price_change_pct) < self.config.price_change_threshold:
            return self.last_vpt
        
        vpt_change = volume * price_change_pct
        new_vpt = self.last_vpt + vpt_change
        
        return new_vpt
    
    def _calculate_smoothed_vpt(self, vpt_value: float) -> float:
        """Calculate smoothed VPT using adaptive EMA"""
        if not self.vpt_smoothed:
            return vpt_value
        
        # Adaptive smoothing based on volatility
        if self.config.adaptive_smoothing:
            volatility = self._calculate_price_volatility()
            alpha = 2 / (self.config.smoothing_period + 1)
            # Adjust alpha based on volatility
            alpha = alpha * (1 + volatility)
            alpha = min(alpha, 0.5)  # Cap maximum smoothing
        else:
            alpha = 2 / (self.config.smoothing_period + 1)
        
        return alpha * vpt_value + (1 - alpha) * self.vpt_smoothed[-1]
    
    def _calculate_price_volatility(self) -> float:
        """Calculate recent price volatility for adaptive smoothing"""
        if len(self.price_changes) < 10:
            return 0.0
        
        recent_changes = self.price_changes[-10:]
        return np.std(recent_changes) if recent_changes else 0.0
    
    def _calculate_volume_ma(self, volume: float) -> float:
        """Calculate volume moving average"""
        self.volumes.append(volume)
        
        if len(self.volumes) < self.config.volume_ma_period:
            return np.mean(self.volumes)
        
        return np.mean(self.volumes[-self.config.volume_ma_period:])
    
    def _analyze_volume_flow(self, close: float, prev_close: float, 
                           volume: float, volume_ma: float) -> VPTVolumeFlow:
        """Analyze volume flow characteristics"""
        # Flow direction based on price movement
        if close > prev_close:
            flow_direction = "bullish"
        elif close < prev_close:
            flow_direction = "bearish"
        else:
            flow_direction = "neutral"
        
        # Flow strength based on price change magnitude and volume
        price_change_pct = abs(close - prev_close) / prev_close if prev_close > 0 else 0
        volume_ratio = volume / volume_ma if volume_ma > 0 else 1.0
        
        flow_strength = min(price_change_pct * volume_ratio * 10, 1.0)
        
        # Volume quality assessment
        if volume_ratio > self.config.volume_surge_threshold:
            volume_quality = min(volume_ratio / self.config.volume_surge_threshold, 2.0) / 2.0
        elif volume_ratio < self.config.volume_dryup_threshold:
            volume_quality = volume_ratio / self.config.volume_dryup_threshold * 0.5
        else:
            volume_quality = 0.7  # Normal volume
        
        # Accumulation rate calculation
        vpt_change = self.vpt_values[-1] - self.vpt_values[-2] if len(self.vpt_values) >= 2 else 0
        accumulation_rate = vpt_change / volume if volume > 0 else 0
        
        # Smart money detection
        smart_money_activity = (
            volume_ratio > self.config.volume_surge_threshold and
            price_change_pct > self.config.price_change_threshold * 2 and
            self.config.smart_money_detection
        )
        
        return VPTVolumeFlow(
            flow_direction=flow_direction,
            flow_strength=flow_strength,
            volume_quality=volume_quality,
            accumulation_rate=accumulation_rate,
            smart_money_activity=smart_money_activity
        )
    
    def _detect_divergence(self, price: float, vpt_value: float) -> Tuple[bool, float]:
        """Detect price-volume divergences"""
        if len(self.prices) < self.config.divergence_lookback:
            return False, 0.0
        
        lookback = self.config.divergence_lookback
        recent_prices = self.prices[-lookback:]
        recent_vpt = self.vpt_values[-lookback:]
        
        # Calculate trends
        price_trend = np.polyfit(range(len(recent_prices)), recent_prices, 1)[0]
        vpt_trend = np.polyfit(range(len(recent_vpt)), recent_vpt, 1)[0]
        
        # Divergence detection
        price_direction = 1 if price_trend > 0 else -1
        vpt_direction = 1 if vpt_trend > 0 else -1
        
        divergence_detected = price_direction != vpt_direction
        divergence_strength = abs(price_trend) * abs(vpt_trend) if divergence_detected else 0.0
        
        return divergence_detected, divergence_strength
    
    def _calculate_breakout_probability(self, vpt_value: float, volume_flow: VPTVolumeFlow) -> float:
        """Calculate probability of price breakout based on VPT"""
        if len(self.vpt_values) < 20:
            return 0.0
        
        # VPT momentum
        recent_vpt = self.vpt_values[-10:]
        vpt_momentum = (recent_vpt[-1] - recent_vpt[0]) / len(recent_vpt)
        
        # Volume strength factor
        volume_factor = volume_flow.volume_quality * volume_flow.flow_strength
        
        # Standard deviation of recent VPT
        vpt_std = np.std(self.vpt_values[-20:])
        current_z_score = abs(vpt_value - np.mean(self.vpt_values[-20:])) / vpt_std if vpt_std > 0 else 0
        
        # Combine factors
        breakout_prob = min((abs(vpt_momentum) + volume_factor + current_z_score / 2) / 3, 1.0)
        
        return breakout_prob
    
    def _determine_trend_state(self, vpt_value: float, volume_flow: VPTVolumeFlow) -> VPTTrendState:
        """Determine overall VPT trend state"""
        if len(self.vpt_values) < 5:
            return VPTTrendState.NEUTRAL_FLOW
        
        # Recent VPT change
        vpt_change = vpt_value - self.vpt_values[-5]
        volume_strength = volume_flow.flow_strength
        
        if vpt_change > 0:
            if volume_strength > 0.7:
                return VPTTrendState.STRONG_ACCUMULATION
            else:
                return VPTTrendState.WEAK_ACCUMULATION
        elif vpt_change < 0:
            if volume_strength > 0.7:
                return VPTTrendState.STRONG_DISTRIBUTION
            else:
                return VPTTrendState.WEAK_DISTRIBUTION
        else:
            return VPTTrendState.NEUTRAL_FLOW
    
    def _calculate_price_volume_sync(self, price_change: float, vpt_change: float) -> float:
        """Calculate how well price and volume movements are synchronized"""
        if abs(price_change) < 1e-10 or abs(vpt_change) < 1e-10:
            return 0.5
        
        # Same direction = good sync, opposite = poor sync
        sync_direction = 1 if (price_change > 0) == (vpt_change > 0) else -1
        
        # Magnitude alignment
        price_magnitude = abs(price_change)
        vpt_magnitude = abs(vpt_change)
        magnitude_ratio = min(price_magnitude, vpt_magnitude) / max(price_magnitude, vpt_magnitude)
        
        sync_score = 0.5 + (sync_direction * magnitude_ratio * 0.5)
        return max(0.0, min(1.0, sync_score))
    
    def update(self, data: Dict[str, float]) -> Optional[IndicatorSignal]:
        """Update VPT with new market data"""
        try:
            close = data['close']
            volume = data['volume']
            
            # Store price and calculate change
            prev_close = self.prices[-1] if self.prices else close
            self.prices.append(close)
            
            price_change = close - prev_close
            price_change_pct = price_change / prev_close if prev_close > 0 else 0
            self.price_changes.append(price_change_pct)
            
            # Calculate VPT
            vpt_value = self._calculate_vpt(close, prev_close, volume)
            self.vpt_values.append(vpt_value)
            self.last_vpt = vpt_value
            
            # Calculate smoothed VPT
            vpt_smoothed = self._calculate_smoothed_vpt(vpt_value)
            self.vpt_smoothed.append(vpt_smoothed)
            
            # Calculate volume MA
            volume_ma = self._calculate_volume_ma(volume)
            self.volume_ma.append(volume_ma)
            
            # Analyze volume flow
            volume_flow = self._analyze_volume_flow(close, prev_close, volume, volume_ma)
            
            # Detect divergence
            divergence_detected, divergence_strength = self._detect_divergence(close, vpt_value)
            
            # Calculate breakout probability
            breakout_probability = self._calculate_breakout_probability(vpt_value, volume_flow)
            
            # Calculate price-volume synchronization
            vpt_change = vpt_value - self.vpt_values[-2] if len(self.vpt_values) >= 2 else 0
            price_volume_sync = self._calculate_price_volume_sync(price_change, vpt_change)
            
            # Determine trend state
            trend_state = self._determine_trend_state(vpt_value, volume_flow)
            
            # Calculate momentum
            vpt_momentum = 0.0
            if len(self.vpt_values) >= 3:
                recent_vpt = self.vpt_values[-3:]
                vpt_momentum = (recent_vpt[-1] - recent_vpt[0]) / 2
            
            # Calculate signal quality
            signal_quality = (
                volume_flow.flow_strength * 0.3 +
                volume_flow.volume_quality * 0.3 +
                price_volume_sync * 0.2 +
                min(breakout_probability, 1.0) * 0.2
            )
            
            # Create analysis
            analysis = VPTAnalysis(
                trend_state=trend_state,
                vpt_value=vpt_value,
                vpt_change=vpt_change,
                vpt_momentum=vpt_momentum,
                volume_flow=volume_flow,
                price_volume_sync=price_volume_sync,
                breakout_probability=breakout_probability,
                divergence_strength=divergence_strength,
                signal_quality=signal_quality
            )
            
            # Generate signals
            return self._generate_signals(analysis, data)
            
        except Exception as e:
            logger.error(f"Error updating VPT: {e}")
            return None
    
    def _generate_signals(self, analysis: VPTAnalysis, data: Dict[str, float]) -> IndicatorSignal:
        """Generate trading signals based on VPT analysis"""
        signals = []
        signal_strength = SignalStrength.NEUTRAL
        confidence = 0.5
        
        # Volume flow signals
        if analysis.volume_flow.smart_money_activity:
            signals.append("Smart money activity detected")
            signal_strength = SignalStrength.STRONG
            confidence += 0.2
        
        # Trend state signals
        if analysis.trend_state == VPTTrendState.STRONG_ACCUMULATION:
            signals.append("Strong volume accumulation - bullish trend confirmation")
            signal_strength = SignalStrength.STRONG
            confidence += 0.25
        elif analysis.trend_state == VPTTrendState.STRONG_DISTRIBUTION:
            signals.append("Strong volume distribution - bearish trend confirmation")
            signal_strength = SignalStrength.STRONG
            confidence += 0.25
        elif analysis.trend_state == VPTTrendState.WEAK_ACCUMULATION:
            signals.append("Weak accumulation - cautious bullish bias")
            signal_strength = SignalStrength.WEAK
            confidence += 0.1
        elif analysis.trend_state == VPTTrendState.WEAK_DISTRIBUTION:
            signals.append("Weak distribution - cautious bearish bias")
            signal_strength = SignalStrength.WEAK
            confidence += 0.1
        
        # Divergence signals
        if analysis.divergence_strength > 0.5:
            signals.append("Significant price-volume divergence detected")
            signal_strength = SignalStrength.STRONG
            confidence += 0.2
        
        # Breakout signals
        if analysis.breakout_probability > 0.7:
            direction = "bullish" if analysis.vpt_change > 0 else "bearish"
            signals.append(f"High probability {direction} breakout indicated by volume")
            signal_strength = SignalStrength.STRONG
            confidence += 0.15
        
        # Volume quality signals
        if analysis.volume_flow.volume_quality > 0.8:
            signals.append("High quality volume supporting price movement")
            confidence += 0.1
        elif analysis.volume_flow.volume_quality < 0.3:
            signals.append("Poor volume quality - price movement unsustainable")
            confidence += 0.05
        
        # Price-volume sync signals
        if analysis.price_volume_sync > 0.8:
            signals.append("Excellent price-volume synchronization")
            confidence += 0.1
        elif analysis.price_volume_sync < 0.3:
            signals.append("Poor price-volume synchronization - trend weakness")
            confidence += 0.05
        
        # Volume momentum signals
        if abs(analysis.vpt_momentum) > np.std(self.vpt_values[-20:]) if len(self.vpt_values) >= 20 else 0:
            direction = "increasing" if analysis.vpt_momentum > 0 else "decreasing"
            signals.append(f"Volume momentum {direction} significantly")
            confidence += 0.1
        
        # Market condition assessment
        market_condition = MarketCondition.TRENDING
        if analysis.trend_state == VPTTrendState.NEUTRAL_FLOW:
            market_condition = MarketCondition.RANGING
        elif analysis.breakout_probability > 0.6:
            market_condition = MarketCondition.VOLATILE
        
        # Adjust confidence based on signal quality
        confidence = min(confidence * analysis.signal_quality, 0.95)
        
        return IndicatorSignal(
            indicator_name=self.name,
            signal_strength=signal_strength,
            confidence=confidence,
            signals=signals,
            market_condition=market_condition,
            metadata={
                'vpt_value': analysis.vpt_value,
                'vpt_change': analysis.vpt_change,
                'vpt_momentum': analysis.vpt_momentum,
                'trend_state': analysis.trend_state.value,
                'flow_direction': analysis.volume_flow.flow_direction,
                'flow_strength': analysis.volume_flow.flow_strength,
                'volume_quality': analysis.volume_flow.volume_quality,
                'accumulation_rate': analysis.volume_flow.accumulation_rate,
                'smart_money_activity': analysis.volume_flow.smart_money_activity,
                'price_volume_sync': analysis.price_volume_sync,
                'breakout_probability': analysis.breakout_probability,
                'divergence_strength': analysis.divergence_strength,
                'signal_quality': analysis.signal_quality
            }
        )
    
    @property
    def name(self) -> str:
        return "Volume Price Trend"
    
    def get_flow_analysis(self) -> Dict[str, Any]:
        """Get detailed volume flow analysis"""
        if not self.vpt_values:
            return {}
        
        return {
            'current_vpt': self.vpt_values[-1],
            'vpt_trend': 'up' if len(self.vpt_values) >= 2 and self.vpt_values[-1] > self.vpt_values[-2] else 'down',
            'volume_quality_score': self.volume_quality_score,
            'trend_strength': self.trend_strength,
            'recent_flow_strength': np.mean([abs(change) for change in self.price_changes[-5:]]) if len(self.price_changes) >= 5 else 0
        }

def test_volume_price_trend():
    """Test VPT implementation with realistic market data"""
    config = VPTConfig(
        smoothing_period=14,
        volume_ma_period=20,
        smart_money_detection=True,
        adaptive_smoothing=True
    )
    
    vpt = VolumePriceTrend(config)
    
    # Generate test data with volume patterns
    np.random.seed(42)
    base_price = 1.2000
    base_volume = 1000000
    
    signals = []
    for i in range(100):
        # Create price movement with volume correlation
        price_change = np.random.normal(0, 0.0005)
        # Volume increases with larger price moves (smart money simulation)
        volume_multiplier = 1 + abs(price_change) * 2000
        # Add volume spikes occasionally
        if i % 15 == 0:
            volume_multiplier *= 2.5  # Volume spike
        
        price = base_price + price_change * (i + 1)
        volume = base_volume * volume_multiplier * (0.8 + 0.4 * np.random.random())
        
        data = {
            'open': price * 0.9999,
            'high': price * 1.0002,
            'low': price * 0.9998,
            'close': price,
            'volume': volume
        }
        
        signal = vpt.update(data)
        if signal and signal.signals:
            signals.append((i, signal))
        
        base_price = price  # Trend continuation
    
    print(f"VPT Test Results:")
    print(f"Total signals generated: {len(signals)}")
    print(f"Final VPT value: {vpt.vpt_values[-1]:.2f}")
    print(f"Divergence points detected: {len(vpt.divergence_points)}")
    
    # Print last few signals
    print("\nRecent signals:")
    for i, signal in signals[-3:]:
        print(f"Bar {i}: {signal.signal_strength.value} - {signal.signals}")
    
    # Test flow analysis
    flow_analysis = vpt.get_flow_analysis()
    print(f"\nFlow Analysis:")
    print(f"Current VPT: {flow_analysis.get('current_vpt', 0):.2f}")
    print(f"VPT Trend: {flow_analysis.get('vpt_trend', 'unknown')}")
    print(f"Volume Quality Score: {flow_analysis.get('volume_quality_score', 0):.3f}")

if __name__ == "__main__":
    test_volume_price_trend()
