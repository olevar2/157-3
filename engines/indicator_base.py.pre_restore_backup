#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Enhanced Indicator Base System with Signal Support
Platform3 Trading Engine - Complete indicator infrastructure
"""

from shared.logging.platform3_logger import Platform3Logger
from shared.error_handling.platform3_error_system import Platform3ErrorSystem, ServiceError
from shared.database.platform3_database_manager import Platform3DatabaseManager
from shared.communication.platform3_communication_framework import Platform3CommunicationFramework
import asyncio
import numpy as np
from typing import Dict, List, Any, Optional, Union
from datetime import datetime
from enum import Enum

class SignalType(Enum):
    """Signal types for trading indicators"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    STRONG_BUY = "STRONG_BUY"
    STRONG_SELL = "STRONG_SELL"
    NEUTRAL = "NEUTRAL"

class IndicatorSignal:
    """
    Represents a trading signal generated by an indicator
    
    This class encapsulates all signal-related information including:
    - Signal type and strength
    - Timestamp and validity
    - Confidence level and metadata
    """
    
    def __init__(self, 
                 signal_type: SignalType, 
                 strength: float = 1.0,
                 confidence: float = 1.0,
                 timestamp: Optional[datetime] = None,
                 metadata: Optional[Dict[str, Any]] = None):
        """
        Initialize a trading signal
        
        Args:
            signal_type: Type of signal (BUY, SELL, HOLD, etc.)
            strength: Signal strength (0.0 to 1.0)
            confidence: Confidence level (0.0 to 1.0)
            timestamp: When the signal was generated
            metadata: Additional signal information
        """
        self.signal_type = signal_type
        self.strength = max(0.0, min(1.0, strength))
        self.confidence = max(0.0, min(1.0, confidence))
        self.timestamp = timestamp or datetime.now()
        self.metadata = metadata or {}
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary"""
        return {
            'signal_type': self.signal_type.value,
            'strength': self.strength,
            'confidence': self.confidence,
            'timestamp': self.timestamp.isoformat(),
            'metadata': self.metadata
        }
    
    def __str__(self) -> str:
        return f"Signal({self.signal_type.value}, strength={self.strength:.2f}, confidence={self.confidence:.2f})"

class IndicatorBase:
    """
    Base class for all technical indicators with Platform3 framework integration
    
    Provides common functionality for indicator calculations including:
    - Error handling and logging
    - Performance monitoring
    - Database operations
    - Real-time processing capabilities
    - Signal generation support
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize IndicatorBase with Platform3 framework components
        
        Args:
            config: Configuration dictionary for the indicator
        """
        self.config = config or {}
        
        # Initialize Platform3 framework components
        self.logger = Platform3Logger('IndicatorBase')
        self.error_system = Platform3ErrorSystem()
        self.db_manager = Platform3DatabaseManager()
        self.comm_framework = Platform3CommunicationFramework()
        
        # Performance monitoring
        self.calculation_times = []
        self.last_calculation = None
        
        # Signal tracking
        self.last_signal = None
        self.signal_history = []
        
        self.logger.info("IndicatorBase initialized successfully")
    
    def calculate(self, data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Calculate trading engine values with enhanced accuracy
        
        Args:
            data: Input price data for processing
            
        Returns:
            Dict containing calculated indicator values
            
        Raises:
            ServiceError: If calculation fails
        """
        start_time = datetime.now()
        
        try:
            # Validate input data
            if not data:
                raise ServiceError("Input data cannot be empty")
                
            if not isinstance(data, list):
                raise ServiceError("Input data must be a list")
                
            # Perform calculation (to be implemented by subclasses)
            result = self._perform_calculation(data)
            
            # Track performance
            calculation_time = (datetime.now() - start_time).total_seconds()
            self.calculation_times.append(calculation_time)
            self.last_calculation = datetime.now()
            
            self.logger.info(f"Calculation completed in {calculation_time:.4f}s")
            
            return {
                'success': True,
                'data': result,
                'timestamp': self.last_calculation.isoformat(),
                'calculation_time': calculation_time
            }
            
        except ServiceError as e:
            self.logger.error(f"Service error: {e}", extra={"error": e.to_dict()})
            self.error_system.handle_error(e)
            raise
        except Exception as e:
            error = ServiceError(f"Calculation failed: {str(e)}")
            self.logger.error(f"Unexpected error: {e}", extra={"error": str(e)})
            self.error_system.handle_error(error)
            raise error
    
    def _perform_calculation(self, data: List[Dict[str, Any]]) -> Any:
        """
        Perform the actual indicator calculation
        
        This method should be overridden by subclasses to implement
        specific indicator logic.
        
        Args:
            data: Input price data
            
        Returns:
            Calculated indicator values
        """
        raise NotImplementedError("Subclasses must implement _perform_calculation")
    
    def generate_signal(self, data: List[Dict[str, Any]]) -> Optional[IndicatorSignal]:
        """
        Generate trading signal based on indicator values
        
        Args:
            data: Input price data
            
        Returns:
            Trading signal or None if no signal generated
        """
        # Default implementation - subclasses should override
        try:
            result = self.calculate(data)
            if result.get('success'):
                # Generate a neutral signal by default
                signal = IndicatorSignal(
                    signal_type=SignalType.NEUTRAL,
                    strength=0.5,
                    confidence=0.5,
                    metadata={'indicator': self.__class__.__name__}
                )
                self.last_signal = signal
                self.signal_history.append(signal)
                return signal
        except Exception as e:
            self.logger.warning(f"Signal generation failed: {e}")
            
        return None
    
    async def calculate_async(self, data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Asynchronous version of calculate for high-frequency trading
        
        Args:
            data: Input price data for processing
            
        Returns:
            Dict containing calculated indicator values
        """
        return await asyncio.get_event_loop().run_in_executor(
            None, self.calculate, data
        )
    
    def get_performance_metrics(self) -> Dict[str, Any]:
        """
        Get performance metrics for the indicator
        
        Returns:
            Dict containing performance statistics
        """
        if not self.calculation_times:
            return {"status": "no_calculations"}
            
        return {
            "total_calculations": len(self.calculation_times),
            "average_time": np.mean(self.calculation_times),
            "min_time": np.min(self.calculation_times),
            "max_time": np.max(self.calculation_times),
            "last_calculation": self.last_calculation.isoformat() if self.last_calculation else None,
            "signal_count": len(self.signal_history)
        }
    
    def reset_performance_metrics(self):
        """Reset performance tracking metrics"""
        self.calculation_times = []
        self.last_calculation = None
        self.signal_history = []
        self.last_signal = None
        self.logger.info("Performance metrics reset")
    
    def validate_data(self, data: List[Dict[str, Any]]) -> bool:
        """
        Validate input data format and content
        
        Args:
            data: Input data to validate
            
        Returns:
            True if data is valid, False otherwise
        """
        if not data or not isinstance(data, list):
            return False
            
        # Check for required fields in each data point
        required_fields = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
        
        for item in data:
            if not isinstance(item, dict):
                return False
                
            for field in required_fields:
                if field not in item:
                    return False
                    
        return True
    
    def get_signal_history(self, limit: Optional[int] = None) -> List[IndicatorSignal]:
        """
        Get signal history
        
        Args:
            limit: Maximum number of signals to return
            
        Returns:
            List of historical signals
        """
        if limit:
            return self.signal_history[-limit:]
        return self.signal_history.copy()
    
    def __str__(self) -> str:
        """String representation of the indicator"""
        return f"IndicatorBase(calculations={len(self.calculation_times)}, signals={len(self.signal_history)})"
    
    def __repr__(self) -> str:
        """Detailed string representation of the indicator"""
        return f"IndicatorBase(config={self.config}, calculations={len(self.calculation_times)}, signals={len(self.signal_history)})"

# Export for use by other modules
__all__ = ['IndicatorBase', 'IndicatorSignal', 'SignalType']