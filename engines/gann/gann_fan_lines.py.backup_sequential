# -*- coding: utf-8 -*-
"""
GANN FAN LINES - Angular Support and Resistance Analysis
Platform3 Advanced Gann Analysis Engine

This module implements W.D. Gann's famous angular support and resistance lines based on 
geometric price-time relationships. Provides precise angular projections for trend analysis.

Features:
- Complete Gann angle calculations (1x8, 1x4, 1x3, 1x2, 1x1, 2x1, 3x1, 4x1, 8x1)
- Dynamic angle strength assessment based on price interaction
- Support and resistance level identification
- Trend strength measurement using angular relationships
- Multi-timeframe angle confluence analysis
- Automatic pivot point detection for angle origination
- Price target projections along Gann angles

Gann Angle Theory:
- 1x1 Line (45degree): Main trend line - most important
- 1x2 Line (26.57degree): Strong support/resistance 
- 2x1 Line (63.43degree): Fast trend acceleration
- 1x4 and 4x1: Secondary support/resistance levels
- 1x8 and 8x1: Extreme angles for major reversals

Trading Applications:
- Trend direction confirmation
- Support/resistance level identification
- Entry and exit point optimization
- Stop-loss placement
- Price target calculation
- Trend strength assessment
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Union
from dataclasses import dataclass
from enum import Enum
import logging
import math
from ..indicator_base import IndicatorBase

class GannAngle(Enum):
    """Gann angle types with their geometric ratios"""
    ANGLE_1X8 = (1, 8, 7.125)    # 1 unit price per 8 units time
    ANGLE_1X4 = (1, 4, 14.036)   # 1 unit price per 4 units time
    ANGLE_1X3 = (1, 3, 18.435)   # 1 unit price per 3 units time
    ANGLE_1X2 = (1, 2, 26.565)   # 1 unit price per 2 units time
    ANGLE_1X1 = (1, 1, 45.000)   # 1 unit price per 1 unit time (main trend)
    ANGLE_2X1 = (2, 1, 63.435)   # 2 units price per 1 unit time
    ANGLE_3X1 = (3, 1, 71.565)   # 3 units price per 1 unit time
    ANGLE_4X1 = (4, 1, 75.964)   # 4 units price per 1 unit time
    ANGLE_8X1 = (8, 1, 82.875)   # 8 units price per 1 unit time
    
    @property
    def ratio(self) -> float:
        """Get price/time ratio"""
        return self.value[0] / self.value[1]
    
    @property
    def degrees(self) -> float:
        """Get angle in degrees"""
        return self.value[2]
    
    @property
    def name_str(self) -> str:
        """Get formatted name"""
        return f"{self.value[0]}x{self.value[1]}"

@dataclass
class GannLine:
    """Individual Gann line with geometric properties"""
    angle: GannAngle
    start_index: int
    start_price: float
    direction: int  # 1 for up-trending, -1 for down-trending
    strength: float  # 0.0 to 1.0
    touches: int
    last_touch_index: int
    is_support: bool
    is_resistance: bool
    current_price: float
    
    def get_price_at_index(self, index: int, price_scale: float = 1.0, time_scale: float = 1.0) -> float:
        """Calculate price at given index along this Gann line"""
        time_diff = (index - self.start_index) * time_scale
        price_change = self.direction * self.angle.ratio * time_diff * price_scale
        return self.start_price + price_change

@dataclass
class GannFanAnalysis:
    """Complete Gann fan analysis results"""
    fan_lines: List[GannLine]
    pivot_point: Tuple[int, float]
    dominant_angle: GannAngle
    trend_strength: float
    support_levels: List[float]
    resistance_levels: List[float]
    price_targets: Dict[str, float]
    confluence_zones: List[Tuple[float, float, int]]  # price, strength, line_count

class GannFanLines(IndicatorBase):
    """
    Advanced Gann Fan Lines Calculator
      Implements W.D. Gann's angular analysis methodology for identifying
    support, resistance, and trend direction using geometric price-time relationships.
    """
    
    def __init__(self, 
                 pivot_sensitivity: float = 0.02,
                 min_touches: int = 2,
                 confluence_tolerance: float = 0.005,
                 auto_scale: bool = True):
        """
        Initialize Gann Fan Lines calculator
        
        Args:
            pivot_sensitivity: Minimum percentage move to identify pivot (2%)
            min_touches: Minimum touches for line validation
            confluence_tolerance: Price tolerance for confluence zones (0.5%)
            auto_scale: Automatically calculate price/time scaling
        """
        from ..indicator_base import IndicatorType, TimeFrame
        
        super().__init__(
            name="GannFanLines",
            indicator_type=IndicatorType.GANN,
            timeframe=TimeFrame.H1,
            lookback_periods=50,
            parameters={
                'pivot_sensitivity': pivot_sensitivity,
                'min_touches': min_touches,
                'confluence_tolerance': confluence_tolerance,
                'auto_scale': auto_scale
            }
        )
        
        self.pivot_sensitivity = pivot_sensitivity
        self.min_touches = min_touches
        self.confluence_tolerance = confluence_tolerance
        self.auto_scale = auto_scale
        
        # Current analysis results
        self.current_analysis = None
        self.price_scale = 1.0
        self.time_scale = 1.0
        
        # Setup logging
        self.logger = logging.getLogger(__name__)
    
    def calculate(self, data: pd.DataFrame, **kwargs) -> Dict:
        """
        Calculate Gann Fan Lines analysis
        
        Args:
            data: Price data DataFrame with OHLC columns
            **kwargs: Additional parameters including:
                - pivot_index: Manual pivot point index
                - pivot_price: Manual pivot point price
                - fan_direction: 1 for up-fan, -1 for down-fan
                
        Returns:
            Dictionary with Gann fan analysis results
        """
        try:
            if len(data) < 20:
                raise ValueError("Insufficient data for Gann fan analysis")
            
            # Auto-calculate scaling factors if enabled
            if self.auto_scale:
                self.price_scale, self.time_scale = self._calculate_scaling_factors(data)
            
            # Identify pivot point
            pivot_index, pivot_price, fan_direction = self._identify_pivot_point(data, **kwargs)
            
            if pivot_index is None:
                return self._get_default_result("No valid pivot point found")
            
            # Calculate all Gann fan lines from pivot
            fan_lines = self._calculate_fan_lines(data, pivot_index, pivot_price, fan_direction)
            
            # Analyze line strength and touches
            self._analyze_line_interactions(fan_lines, data, pivot_index)
            
            # Identify support and resistance levels
            support_levels, resistance_levels = self._identify_support_resistance(fan_lines, data.iloc[-1]['close'])
            
            # Find confluence zones
            confluence_zones = self._find_confluence_zones(fan_lines, data.iloc[-1]['close'])
            
            # Calculate price targets
            price_targets = self._calculate_price_targets(fan_lines, data.iloc[-1]['close'])
            
            # Determine dominant angle and trend strength
            dominant_angle, trend_strength = self._analyze_trend_strength(fan_lines, data.iloc[-1]['close'])
            
            # Create analysis result
            self.current_analysis = GannFanAnalysis(
                fan_lines=fan_lines,
                pivot_point=(pivot_index, pivot_price),
                dominant_angle=dominant_angle,
                trend_strength=trend_strength,
                support_levels=support_levels,
                resistance_levels=resistance_levels,
                price_targets=price_targets,
                confluence_zones=confluence_zones
            )
            
            return {
                'fan_lines': [self._line_to_dict(line) for line in fan_lines],
                'pivot_point': {
                    'index': pivot_index,
                    'price': pivot_price,
                    'direction': fan_direction
                },
                'dominant_angle': {
                    'angle': dominant_angle.name_str,
                    'degrees': dominant_angle.degrees,
                    'ratio': dominant_angle.ratio
                },
                'trend_strength': trend_strength,
                'support_levels': support_levels,
                'resistance_levels': resistance_levels,
                'price_targets': price_targets,
                'confluence_zones': [
                    {
                        'price': zone[0],
                        'strength': zone[1],
                        'line_count': zone[2]
                    }
                    for zone in confluence_zones
                ],
                'scaling': {
                    'price_scale': self.price_scale,
                    'time_scale': self.time_scale
                },
                'current_price': data.iloc[-1]['close'],
                'total_lines': len(fan_lines),
                'active_lines': len([line for line in fan_lines if line.strength > 0.3])
            }
            
        except Exception as e:
            self.logger.error(f"Error calculating Gann fan lines: {e}")
            return self._get_default_result(f"Calculation error: {e}")
    
    def _calculate_scaling_factors(self, data: pd.DataFrame) -> Tuple[float, float]:
        """Calculate optimal price and time scaling factors"""
        try:
            # Price range analysis
            price_range = data['high'].max() - data['low'].min()
            avg_price = data['close'].mean()
            
            # Time analysis (use index as time units)
            time_range = len(data)
            
            # Calculate scaling to normalize price/time relationship
            # Goal: make 1x1 angle meaningful relative to price volatility
            avg_daily_range = (data['high'] - data['low']).mean()
            
            # Price scale: normalize to make daily moves meaningful
            price_scale = avg_daily_range / avg_price
            
            # Time scale: normalize to trading session length
            time_scale = 1.0  # Keep time in original units (bars/candles)
            
            return price_scale, time_scale
            
        except Exception as e:
            self.logger.error(f"Error calculating scaling factors: {e}")
            return 1.0, 1.0
    
    def _identify_pivot_point(self, data: pd.DataFrame, **kwargs) -> Tuple[Optional[int], Optional[float], int]:
        """Identify pivot point for fan origination"""
        
        # Check for manual pivot specification
        if 'pivot_index' in kwargs and 'pivot_price' in kwargs:
            pivot_index = kwargs['pivot_index']
            pivot_price = kwargs['pivot_price']
            fan_direction = kwargs.get('fan_direction', 1)
            return pivot_index, pivot_price, fan_direction
        
        # Auto-detect significant pivot points
        pivots = self._find_significant_pivots(data)
        
        if not pivots:
            return None, None, 1
        
        # Use most recent significant pivot
        pivot = pivots[-1]
        return pivot['index'], pivot['price'], pivot['direction']
    
    def _find_significant_pivots(self, data: pd.DataFrame) -> List[Dict]:
        """Find significant swing highs and lows for pivot identification"""
        pivots = []
        
        try:
            # Look for swing highs and lows
            lookback = min(10, len(data) // 4)
            
            for i in range(lookback, len(data) - lookback):
                current_high = data.iloc[i]['high']
                current_low = data.iloc[i]['low']
                
                # Check for swing high
                is_swing_high = True
                for j in range(i - lookback, i + lookback + 1):
                    if j != i and data.iloc[j]['high'] >= current_high:
                        is_swing_high = False
                        break
                
                # Check for swing low
                is_swing_low = True
                for j in range(i - lookback, i + lookback + 1):
                    if j != i and data.iloc[j]['low'] <= current_low:
                        is_swing_low = False
                        break
                
                # Calculate significance based on price movement
                if is_swing_high:
                    price_move = 0
                    for j in range(max(0, i - lookback), min(len(data), i + lookback)):
                        move = abs(current_high - data.iloc[j]['close']) / data.iloc[j]['close']
                        price_move = max(price_move, move)
                    
                    if price_move >= self.pivot_sensitivity:
                        pivots.append({
                            'index': i,
                            'price': current_high,
                            'type': 'high',
                            'direction': -1,  # Down-fan from high
                            'significance': price_move
                        })
                
                if is_swing_low:
                    price_move = 0
                    for j in range(max(0, i - lookback), min(len(data), i + lookback)):
                        move = abs(current_low - data.iloc[j]['close']) / data.iloc[j]['close']
                        price_move = max(price_move, move)
                    
                    if price_move >= self.pivot_sensitivity:
                        pivots.append({
                            'index': i,
                            'price': current_low,
                            'type': 'low',
                            'direction': 1,  # Up-fan from low
                            'significance': price_move
                        })
            
            # Sort by significance and return most significant recent pivots
            pivots.sort(key=lambda x: x['significance'], reverse=True)
            return pivots[:5]  # Top 5 most significant pivots
            
        except Exception as e:
            self.logger.error(f"Error finding pivots: {e}")
            return []
    
    def _calculate_fan_lines(self, 
                           data: pd.DataFrame, 
                           pivot_index: int, 
                           pivot_price: float, 
                           direction: int) -> List[GannLine]:
        """Calculate all Gann fan lines from pivot point"""
        fan_lines = []
        
        try:
            current_index = len(data) - 1
            
            for angle in GannAngle:
                # Calculate current price along this angle
                current_price = self._calculate_angle_price(
                    pivot_index, pivot_price, current_index, angle, direction)
                
                gann_line = GannLine(
                    angle=angle,
                    start_index=pivot_index,
                    start_price=pivot_price,
                    direction=direction,
                    strength=0.0,  # Will be calculated later
                    touches=0,     # Will be calculated later
                    last_touch_index=-1,
                    is_support=False,  # Will be determined later
                    is_resistance=False,  # Will be determined later
                    current_price=current_price
                )
                
                fan_lines.append(gann_line)
            
        except Exception as e:
            self.logger.error(f"Error calculating fan lines: {e}")
        
        return fan_lines
    
    def _calculate_angle_price(self, 
                             start_index: int, 
                             start_price: float, 
                             target_index: int, 
                             angle: GannAngle, 
                             direction: int) -> float:
        """Calculate price at target index along Gann angle"""
        time_diff = (target_index - start_index) * self.time_scale
        price_change = direction * angle.ratio * time_diff * self.price_scale
        return start_price + price_change
    
    def _analyze_line_interactions(self, 
                                 fan_lines: List[GannLine], 
                                 data: pd.DataFrame, 
                                 pivot_index: int) -> None:
        """Analyze how price interacts with each Gann line"""
        
        for line in fan_lines:
            touches = 0
            touch_strength = 0.0
            last_touch = -1
            
            # Analyze price interaction from pivot onwards
            for i in range(pivot_index + 1, len(data)):
                line_price = self._calculate_angle_price(
                    line.start_index, line.start_price, i, line.angle, line.direction)
                
                high = data.iloc[i]['high']
                low = data.iloc[i]['low']
                close = data.iloc[i]['close']
                
                # Check for touch with tolerance
                touch_tolerance = close * 0.005  # 0.5% tolerance
                
                if low <= line_price + touch_tolerance and high >= line_price - touch_tolerance:
                    touches += 1
                    last_touch = i
                    
                    # Calculate touch strength based on how close price came to line
                    if high >= line_price >= low:
                        # Direct touch
                        touch_strength += 1.0
                    else:
                        # Near touch
                        distance = min(abs(high - line_price), abs(low - line_price))
                        proximity = max(0, 1.0 - (distance / touch_tolerance))
                        touch_strength += proximity
            
            # Update line properties
            line.touches = touches
            line.last_touch_index = last_touch
            line.strength = min(1.0, touch_strength / 10.0)  # Normalize to 0-1
            
            # Determine support/resistance characteristics
            current_price = data.iloc[-1]['close']
            if line.current_price < current_price and touches >= self.min_touches:
                line.is_support = True
            elif line.current_price > current_price and touches >= self.min_touches:
                line.is_resistance = True
    
    def _identify_support_resistance(self, 
                                   fan_lines: List[GannLine], 
                                   current_price: float) -> Tuple[List[float], List[float]]:
        """Identify support and resistance levels from fan lines"""
        support_levels = []
        resistance_levels = []
        
        for line in fan_lines:
            if line.strength >= 0.3:  # Only consider strong lines
                if line.is_support:
                    support_levels.append(line.current_price)
                elif line.is_resistance:
                    resistance_levels.append(line.current_price)
        
        # Sort levels
        support_levels.sort(reverse=True)  # Highest support first
        resistance_levels.sort()  # Lowest resistance first
        
        return support_levels[:5], resistance_levels[:5]  # Top 5 each
    
    def _find_confluence_zones(self, 
                             fan_lines: List[GannLine], 
                             current_price: float) -> List[Tuple[float, float, int]]:
        """Find price levels where multiple Gann lines converge"""
        confluence_zones = []
        
        # Get all current line prices
        line_prices = [(line.current_price, line.strength) for line in fan_lines if line.strength > 0.2]
        
        if len(line_prices) < 2:
            return confluence_zones
        
        # Sort by price
        line_prices.sort(key=lambda x: x[0])
        
        # Find confluence groups
        tolerance = current_price * self.confluence_tolerance
        
        i = 0
        while i < len(line_prices):
            confluence_group = [line_prices[i]]
            j = i + 1
            
            # Find all lines within tolerance
            while j < len(line_prices) and line_prices[j][0] - line_prices[i][0] <= tolerance:
                confluence_group.append(line_prices[j])
                j += 1
            
            # Create confluence zone if multiple lines
            if len(confluence_group) >= 2:
                avg_price = np.mean([price for price, _ in confluence_group])
                total_strength = sum([strength for _, strength in confluence_group])
                line_count = len(confluence_group)
                
                confluence_zones.append((avg_price, total_strength, line_count))
            
            i = j if j > i + 1 else i + 1
        
        # Sort by strength
        confluence_zones.sort(key=lambda x: x[1], reverse=True)
        
        return confluence_zones[:5]  # Top 5 confluence zones
    
    def _calculate_price_targets(self, 
                               fan_lines: List[GannLine], 
                               current_price: float) -> Dict[str, float]:
        """Calculate price targets based on Gann line projections"""
        targets = {}
        
        # Find strongest lines for targets
        strong_lines = [line for line in fan_lines if line.strength > 0.5]
        strong_lines.sort(key=lambda x: x.strength, reverse=True)
        
        if strong_lines:
            # Primary target from strongest line
            strongest = strong_lines[0]
            if strongest.is_support and current_price > strongest.current_price:
                targets['primary_support'] = strongest.current_price
            elif strongest.is_resistance and current_price < strongest.current_price:
                targets['primary_resistance'] = strongest.current_price
        
        # Secondary targets from other strong lines
        for i, line in enumerate(strong_lines[1:3], 1):  # Next 2 strongest
            if line.is_support and current_price > line.current_price:
                targets[f'support_{i}'] = line.current_price
            elif line.is_resistance and current_price < line.current_price:
                targets[f'resistance_{i}'] = line.current_price
        
        # Special Gann angle targets
        main_trend_line = next((line for line in fan_lines if line.angle == GannAngle.ANGLE_1X1), None)
        if main_trend_line and main_trend_line.strength > 0.3:
            targets['main_trend_1x1'] = main_trend_line.current_price
        
        return targets
    
    def _analyze_trend_strength(self, 
                              fan_lines: List[GannLine], 
                              current_price: float) -> Tuple[GannAngle, float]:
        """Analyze trend strength and identify dominant angle"""
        
        # Find which angle the price is closest to
        min_distance = float('inf')
        closest_angle = GannAngle.ANGLE_1X1
        
        for line in fan_lines:
            distance = abs(current_price - line.current_price) / current_price
            if distance < min_distance:
                min_distance = distance
                closest_angle = line.angle
        
        # Calculate trend strength based on line interactions
        total_strength = sum(line.strength for line in fan_lines)
        avg_strength = total_strength / len(fan_lines) if fan_lines else 0.0
        
        # Adjust strength based on dominant angle
        if closest_angle in [GannAngle.ANGLE_1X1, GannAngle.ANGLE_1X2, GannAngle.ANGLE_2X1]:
            # Strong trend angles
            trend_strength = min(1.0, avg_strength * 1.2)
        else:
            # Weaker trend angles
            trend_strength = avg_strength * 0.8
        
        return closest_angle, trend_strength
    
    def _line_to_dict(self, line: GannLine) -> Dict:
        """Convert GannLine to dictionary representation"""
        return {
            'angle': line.angle.name_str,
            'angle_degrees': line.angle.degrees,
            'angle_ratio': line.angle.ratio,
            'start_index': line.start_index,
            'start_price': line.start_price,
            'current_price': line.current_price,
            'direction': line.direction,
            'strength': line.strength,
            'touches': line.touches,
            'last_touch_index': line.last_touch_index,
            'is_support': line.is_support,
            'is_resistance': line.is_resistance
        }
    
    def _get_default_result(self, error_message: str = "") -> Dict:
        """Return default result structure"""
        return {
            'fan_lines': [],
            'pivot_point': {'index': 0, 'price': 0.0, 'direction': 1},
            'dominant_angle': {'angle': '1x1', 'degrees': 45.0, 'ratio': 1.0},
            'trend_strength': 0.0,
            'support_levels': [],
            'resistance_levels': [],
            'price_targets': {},
            'confluence_zones': [],
            'scaling': {'price_scale': 1.0, 'time_scale': 1.0},
            'current_price': 0.0,
            'total_lines': 0,
            'active_lines': 0,
            'error': error_message
        }
    
    def get_signal(self, current_price: Optional[float] = None) -> Dict:
        """
        Get trading signal based on Gann fan analysis
        
        Args:
            current_price: Current market price (optional)
            
        Returns:
            Dictionary with signal information
        """
        if not self.current_analysis:
            return {'signal': 'NEUTRAL', 'strength': 0.0, 'reason': 'No Gann analysis available'}
        
        analysis = self.current_analysis
        
        # Use provided price or analysis current price
        price = current_price or (analysis.fan_lines[0].current_price if analysis.fan_lines else 0.0)
        
        # Signal logic based on Gann fan analysis
        signal = 'NEUTRAL'
        strength = 0.0
        reason = 'No clear Gann signal'
        
        # Check dominant angle for trend direction
        if analysis.trend_strength > 0.6:
            # Strong trend detected
            if analysis.dominant_angle in [GannAngle.ANGLE_1X1, GannAngle.ANGLE_2X1, GannAngle.ANGLE_1X2]:
                # Price above/below main trend lines
                main_line = next((line for line in analysis.fan_lines 
                                if line.angle == analysis.dominant_angle), None)
                
                if main_line:
                    if price > main_line.current_price and main_line.direction > 0:
                        signal = 'BUY'
                        strength = analysis.trend_strength
                        reason = f'Price above {analysis.dominant_angle.name_str} uptrend line'
                    elif price < main_line.current_price and main_line.direction < 0:
                        signal = 'SELL'
                        strength = analysis.trend_strength  
                        reason = f'Price below {analysis.dominant_angle.name_str} downtrend line'
        
        # Check for confluence zone signals
        if not signal == 'NEUTRAL':
            for zone in analysis.confluence_zones:
                if abs(price - zone[0]) / price < 0.01:  # Within 1% of confluence
                    strength = min(1.0, strength + zone[1] * 0.2)
                    reason += f' + confluence zone at {zone[0]:.4f}'
                    break
        
        return {
            'signal': signal,
            'strength': strength,
            'reason': reason,
            'dominant_angle': analysis.dominant_angle.name_str,
            'trend_strength': analysis.trend_strength,
            'confluence_zones': len(analysis.confluence_zones)
        }

    def generate_signal(self, current_result, historical_results=None):
        """
        Generate trading signal based on Gann fan line analysis
        
        Args:
            current_result: Current calculation result
            historical_results: Historical results (optional)
            
        Returns:
            Trading signal based on Gann fan analysis
        """
        if not current_result or 'signal' not in current_result:
            return None
            
        signal_type = current_result['signal']
        strength = current_result.get('strength', 0.5)
        
        from ..indicator_base import IndicatorSignal, SignalType
        
        # Map signal types
        signal_mapping = {
            'buy': SignalType.BUY,
            'strong_buy': SignalType.STRONG_BUY,
            'sell': SignalType.SELL, 
            'strong_sell': SignalType.STRONG_SELL,
            'hold': SignalType.HOLD,
            'neutral': SignalType.NEUTRAL
        }
        
        signal_enum = signal_mapping.get(signal_type, SignalType.NEUTRAL)
        
        return IndicatorSignal(
            signal_type=signal_enum,
            strength=strength,
            message=current_result.get('reason', 'Gann fan analysis'),
            timestamp=current_result.get('timestamp', pd.Timestamp.now()),
            price_level=current_result.get('current_price', None),
            confidence=strength
        )
